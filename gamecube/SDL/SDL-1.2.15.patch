diff --git a/README.ogc b/README.ogc
new file mode 100644
index 0000000000..ccda9877c4
--- /dev/null
+++ b/README.ogc
@@ -0,0 +1,37 @@
+# SDL port for Nintendo GameCube/Wii
+
+This port uses the libogc library and the devkitPPC toolchain, available from
+http://www.devkitpro.org
+
+
+## Installation instructions
+
+We highly recommend using the devkitPro pre-built packages provided via pacman
+(https://devkitpro.org/wiki/devkitPro_pacman) unless intending to contribute
+changes to this port.
+
+
+## Build instructions
+
+If you need to hack on libSDL itself then the best way to start is by cloning
+the package repo at https://github.com/devkitPro/pacman-packages. The GameCube
+package is found under gamecube/SDL and the wii one, surprisingly, under
+wii/SDL. cd to the appropriate directory and run makepkg PKGDEST=. there
+(on systems without a native pacman this will be dkp-pacman). This will produce
+a .pkg.tar.zst file in the current directory which can then be installed for
+testing with (dkp-)pacman -U ./<name>.pkg.tar.zst. Once that's done you can
+modify the code under src/SDL-1.2.15/. To build with your changes first source
+the appropriate toolchain vars script - either /opt/devkitpro/wiivars.sh or
+/opt/devkitpro/cubevars.sh then run make. To install you can run sudo -E make
+install.
+
+The easiest way to contribute changes is to fork our SDL repo at
+https://github.com/devkitPro/SDL/ then clone that to src/SDL-1.2.15, replacing
+the extracted source. This port is on the ogc-sdl-1.2 branch. Create your own
+branch from that, commit your changes and make a PR request to the devkitPro
+repo.
+
+If you need further assistance with this then please ask on the forums at
+https://devkitpro.org/viewforum.php?f=40
+
+Happy hacking!
\ No newline at end of file
diff --git a/configure.in b/configure.in
index 08c8e1e97c..be3f073d64 100644
--- a/configure.in
+++ b/configure.in
@@ -925,6 +925,99 @@ AC_HELP_STRING([--enable-ipod], [configure SDL to work with iPodLinux [[default=
     fi
 }
 
+CheckOpenGX()
+{
+    AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+    AC_MSG_CHECKING(for opengx)
+    if test x$PKG_CONFIG != xno; then
+        OPENGX_CFLAGS=`$PKG_CONFIG --cflags opengl`
+        OPENGX_LIBS=`$PKG_CONFIG --libs opengl`
+        opengx=yes
+        AC_DEFINE(SDL_VIDEO_OPENGL)
+    fi
+    AC_MSG_RESULT($opengx)
+}
+
+CheckNintendoWii()
+{
+    AC_ARG_ENABLE(nintendo-wii,
+AC_HELP_STRING([--enable-nintendo-wii], [configure SDL to work with Nintendo Wii [[default=no]]]),
+        , enable_nintendo_wii=no)
+    if test x$enable_nintendo_wii = xyes; then
+        ARCH=nintendo-wii
+        WII_CFLAGS="-mrvl -mcpu=750 -meabi -mhard-float \
+                     -Wall -O2 \
+                     -I${DEVKITPRO}/libogc/include -DGEKKO \
+                     -I${DEVKITPRO}/portlibs/wii/include \
+                     -I${DEVKITPRO}/portlibs/ppc/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $WII_CFLAGS"
+        CFLAGS="$CFLAGS $WII_CFLAGS $OPENGX_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $WII_CFLAGS"
+        SDL_LIBS="-mrvl -mcpu=750 -meabi -mhard-float \
+                  -L${DEVKITPRO}/portlibs/wii/lib \
+                  -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS $OPENGX_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/wii -laesnd -lwiiuse -lbte -lwiikeyboard -lfat -lopengx -logc -lm"
+        AC_DEFINE(SDL_TIMER_OGC)
+        SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
+        have_timers=yes
+        AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
+        have_audio=yes
+        AC_DEFINE(SDL_JOYSTICK_OGC)
+        SOURCES="$SOURCES $srcdir/src/joystick/ogc/*.c"
+        have_joystick=yes
+        AC_DEFINE(SDL_THREAD_OGC)
+        SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
+        have_threads=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/video/wii/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/ogc/*.c"
+        SDLMAIN_SOURCES="$srcdir/src/main/wii/*.c"
+        SDLMAIN_LDFLAGS="-static"
+        have_video=yes
+    fi
+}
+
+CheckNintendoGamecube()
+{
+    AC_ARG_ENABLE(nintendo-gamecube,
+AC_HELP_STRING([--enable-nintendo-gamecube], [configure SDL to work with Nintendo Gamecube [[default=no]]]),
+        , enable_nintendo_wii=no)
+    if test x$enable_nintendo_gamecube = xyes; then
+        ARCH=nintendo-gamecube
+        GAMECUBE_CFLAGS="-mogc -mcpu=750 -meabi -mhard-float \
+                     -Wall -O2 \
+                     -I${DEVKITPRO}/libogc/include -DGEKKO \
+                     -I${DEVKITPRO}/portlibs/gamecube/include \
+                     -I${DEVKITPRO}/portlibs/ppc/include"
+        EXTRA_CFLAGS="$EXTRA_CFLAGS $GAMECUBE_CFLAGS"
+        CFLAGS="$CFLAGS $GAMECUBE_CFLAGS $OPENGX_CFLAGS"
+        SDL_CFLAGS="$SDL_CFLAGS $GAMECUBE_CFLAGS"
+        SDL_LIBS="-mogc -mcpu=750 -meabi -mhard-float \
+                  -L${DEVKITPRO}/portlibs/gamecube/lib \
+                  -L${DEVKITPRO}/portlibs/ppc/lib -lSDLmain $SDL_LIBS $OPENGX_LIBS \
+                  -L${DEVKITPRO}/libogc/lib/cube -laesnd -lfat -logc -lm"
+        AC_DEFINE(SDL_TIMER_OGC)
+        SOURCES="$SOURCES $srcdir/src/timer/ogc/*.c"
+        have_timers=yes
+        AC_DEFINE(SDL_AUDIO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/audio/ogc/*.c"
+        have_audio=yes
+        AC_DEFINE(SDL_JOYSTICK_OGC)
+        SOURCES="$SOURCES $srcdir/src/joystick/ogc/*.c"
+        have_joystick=yes
+        AC_DEFINE(SDL_THREAD_OGC)
+        SOURCES="$SOURCES $srcdir/src/thread/ogc/*.c"
+        have_threads=yes
+        AC_DEFINE(SDL_VIDEO_DRIVER_OGC)
+        SOURCES="$SOURCES $srcdir/src/video/gamecube/*.c"
+        SOURCES="$SOURCES $srcdir/src/video/ogc/*.c"
+        SDLMAIN_SOURCES="$srcdir/src/main/gamecube/*.c"
+        SDLMAIN_LDFLAGS="-static"
+        have_video=yes
+    fi
+}
+
 dnl Find the nanox include and library directories
 CheckNANOX()
 {
@@ -2314,6 +2407,11 @@ AC_HELP_STRING([--enable-rpath], [use an rpath when linking SDL [[default=yes]]]
 
 dnl Set up the configuration based on the host platform!
 case "$host" in
+    powerpc-*-eabi)
+       CheckOpenGX
+       CheckNintendoWii
+       CheckNintendoGamecube
+       ;;
     arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
         ARCH=linux
         CheckDummyVideo
diff --git a/include/SDL_config.h.in b/include/SDL_config.h.in
index 8bb1773c0e..fa020eff5d 100644
--- a/include/SDL_config.h.in
+++ b/include/SDL_config.h.in
@@ -185,6 +185,7 @@
 #undef SDL_AUDIO_DRIVER_SNDMGR
 #undef SDL_AUDIO_DRIVER_SUNAUDIO
 #undef SDL_AUDIO_DRIVER_WAVEOUT
+#undef SDL_AUDIO_DRIVER_OGC
 
 /* Enable various cdrom drivers */
 #undef SDL_CDROM_AIX
@@ -215,6 +216,7 @@
 #undef SDL_JOYSTICK_MINT
 #undef SDL_JOYSTICK_OS2
 #undef SDL_JOYSTICK_RISCOS
+#undef SDL_JOYSTICK_OGC
 #undef SDL_JOYSTICK_WINMM
 #undef SDL_JOYSTICK_USBHID
 #undef SDL_JOYSTICK_USBHID_MACHINE_JOYSTICK_H
@@ -238,6 +240,7 @@
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX
 #undef SDL_THREAD_PTHREAD_RECURSIVE_MUTEX_NP
 #undef SDL_THREAD_SPROC
+#undef SDL_THREAD_OGC
 #undef SDL_THREAD_WIN32
 
 /* Enable various timer systems */
@@ -249,6 +252,7 @@
 #undef SDL_TIMER_OS2
 #undef SDL_TIMER_RISCOS
 #undef SDL_TIMER_UNIX
+#undef SDL_TIMER_OGC
 #undef SDL_TIMER_WIN32
 #undef SDL_TIMER_WINCE
 
@@ -279,6 +283,7 @@
 #undef SDL_VIDEO_DRIVER_SVGALIB
 #undef SDL_VIDEO_DRIVER_TOOLBOX
 #undef SDL_VIDEO_DRIVER_VGL
+#undef SDL_VIDEO_DRIVER_OGC
 #undef SDL_VIDEO_DRIVER_WINDIB
 #undef SDL_VIDEO_DRIVER_WSCONS
 #undef SDL_VIDEO_DRIVER_X11
diff --git a/include/SDL_main.h b/include/SDL_main.h
index ab50ef1e29..9824c50634 100644
--- a/include/SDL_main.h
+++ b/include/SDL_main.h
@@ -32,7 +32,8 @@
 #if defined(__WIN32__) || \
     (defined(__MWERKS__) && !defined(__BEOS__)) || \
     defined(__MACOS__) || defined(__MACOSX__) || \
-    defined(__SYMBIAN32__) || defined(QWS)
+    defined(__SYMBIAN32__) || defined(QWS) || \
+    defined(__wii__) || defined(__gamecube__)
 
 #ifdef __cplusplus
 #define C_LINKAGE	"C"
diff --git a/src/SDL.c b/src/SDL.c
index 87f1b1af2a..bcb53f7e0d 100644
--- a/src/SDL.c
+++ b/src/SDL.c
@@ -121,6 +121,10 @@ int SDL_InitSubSystem(Uint32 flags)
 		if ( SDL_JoystickInit() < 0 ) {
 			return(-1);
 		}
+// joystick 0 is used for mouse emulation on wii & cube.
+#if defined (__wii__) || defined (__gamecube__)
+		SDL_JoystickOpen(0);
+#endif
 		SDL_initialized |= SDL_INIT_JOYSTICK;
 	}
 #else
@@ -155,6 +159,10 @@ int SDL_Init(Uint32 flags)
 	}
 #endif
 
+// On Wii & GameCube always initialise joysticks.
+#if defined(__wii__) || defined (__gamecube__)
+  flags |= SDL_INIT_JOYSTICK;
+#endif
 	/* Clear the error message */
 	SDL_ClearError();
 
diff --git a/src/audio/SDL_audio.c b/src/audio/SDL_audio.c
index beb26e0b4d..fbbeb459f7 100644
--- a/src/audio/SDL_audio.c
+++ b/src/audio/SDL_audio.c
@@ -112,6 +112,9 @@ static AudioBootStrap *bootstrap[] = {
 #endif
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 	&EPOCAudio_bootstrap,
+#endif
+#if SDL_AUDIO_DRIVER_OGC
+	&OGCAUD_bootstrap,
 #endif
 	NULL
 };
diff --git a/src/audio/SDL_sysaudio.h b/src/audio/SDL_sysaudio.h
index 74ac21df04..e701a570ac 100644
--- a/src/audio/SDL_sysaudio.h
+++ b/src/audio/SDL_sysaudio.h
@@ -179,6 +179,9 @@ extern AudioBootStrap DART_bootstrap;
 #if SDL_AUDIO_DRIVER_EPOCAUDIO
 extern AudioBootStrap EPOCAudio_bootstrap; 
 #endif
+#if SDL_AUDIO_DRIVER_OGC
+extern AudioBootStrap OGCAUD_bootstrap;
+#endif
 
 /* This is the current audio device */
 extern SDL_AudioDevice *current_audio;
diff --git a/src/audio/ogc/SDL_ogcAudio.c b/src/audio/ogc/SDL_ogcAudio.c
new file mode 100644
index 0000000000..dab1c0134b
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcAudio.c
@@ -0,0 +1,293 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken at libsdl.or
+*/
+#include "SDL_config.h"
+
+// Public includes.
+#include "SDL_timer.h"
+
+// Audio internal includes.
+#include "SDL_audio.h"
+#include "../SDL_audiomem.h"
+#include "../SDL_sysaudio.h"
+#include "../SDL_audio_c.h"
+
+// Wii audio internal includes.
+#include "SDL_ogcAudio.h"
+
+#include <stdio.h>
+
+// for memalign
+#include <malloc.h>
+
+static const char OGCAUD_DRIVER_NAME[] = "ogc";
+
+#define DMA_BUFFER_SIZE (SAMPLES_PER_DMA_BUFFER*2*sizeof(short))
+
+static lwp_t athread;
+static ogcAudio *current = NULL;
+
+/****************************************************************************
+ * Audio Threading
+ ***************************************************************************/
+static void *
+AudioThread (ogcAudio *private)
+{
+	u32 buffer_size;
+	Uint8 whichab = 1;
+
+	while (1)
+	{
+		LWP_SuspendThread(athread);
+		if (private->stopaudio)
+			break;
+
+		DCZeroRange(private->dma_buffers[whichab], DMA_BUFFER_SIZE);
+		buffer_size = DMA_BUFFER_SIZE;
+
+		// Is the device ready?
+		if (current_audio && !current_audio->paused)
+		{
+			SDL_LockMutex(current_audio->mixer_lock);
+
+			if (current_audio->convert.needed)
+			{
+				// Get the client to produce audio
+				current_audio->spec.callback(
+						current_audio->spec.userdata,
+						current_audio->convert.buf,
+						current_audio->convert.len);
+
+				// Convert the audio
+				SDL_ConvertAudio(&current_audio->convert);
+
+				// Copy from SDL buffer to DMA buffer
+				memcpy(private->dma_buffers[whichab], current_audio->convert.buf, current_audio->convert.len_cvt);
+				buffer_size = current_audio->convert.len_cvt;
+			} else {
+				current_audio->spec.callback(
+					current_audio->spec.userdata,
+					(Uint8 *)(private->dma_buffers[whichab]),
+					DMA_BUFFER_SIZE);
+				buffer_size = DMA_BUFFER_SIZE;
+			}
+
+			SDL_UnlockMutex(current_audio->mixer_lock);
+		}
+		else if (current_audio && (current_audio->spec.format&0x8000)==0) // hack
+		{
+			int i;
+			// if it's an unsigned format use 0x8000 for silence (16-bit)
+			short fill = 0x8000;
+
+			// 0x80 for 8-bit formats
+			if (current_audio->spec.format&0x08)
+				fill |= 0x80;
+
+			for (i=0; i < SAMPLES_PER_DMA_BUFFER*2; i++)
+				private->dma_buffers[whichab][i] = fill;
+		}
+
+		AESND_SetVoiceBuffer(private->voice, private->dma_buffers[whichab], buffer_size);
+		whichab ^= 1;
+	}
+	return NULL;
+}
+
+/****************************************************************************
+ * DMACallback
+ * signal audio thread that more samples are required
+ ***************************************************************************/
+static void
+DMACallback(AESNDPB *pb, u32 state)
+{
+	if (state == VOICE_STATE_STREAM)
+		LWP_ResumeThread(athread);
+}
+
+void OGC_AudioStop(ogcAudio *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
+	}
+
+	if (private->voice) {
+		AESND_SetVoiceStop(private->voice, 1);
+		AESND_FreeVoice(private->voice);
+		private->voice = NULL;
+	}
+
+	private->stopaudio = true;
+	if (athread != LWP_THREAD_NULL) {
+		LWP_ResumeThread(athread);
+		LWP_JoinThread(athread, NULL);
+		athread = LWP_THREAD_NULL;
+	}
+
+	AESND_Pause(1);
+	// this function is broken
+	//AESND_Reset();
+}
+
+int OGC_AudioStart(ogcAudio *private)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return -1;
+		private = current;
+	}
+
+	memset(private->dma_buffers, 0, sizeof(private->dma_buffers));
+	private->stopaudio = false;
+	private->voice = AESND_AllocateVoice(DMACallback);
+	if (private->voice==NULL)
+		return -1;
+
+	if (LWP_CreateThread(&athread, (void*(*)(void*))AudioThread, private, private->astack, AUDIOSTACK, 80) < 0) {
+		AESND_FreeVoice(private->voice);
+		private->voice = NULL;
+		return -1;
+	}
+
+	// start audio
+	// this is retarded. Why isn't there one function to do all this shit?
+	AESND_SetVoiceFormat(private->voice, private->format);
+	AESND_SetVoiceFrequency(private->voice, private->freq);
+	AESND_SetVoiceBuffer(private->voice, private->dma_buffers[0], DMA_BUFFER_SIZE);
+	AESND_SetVoiceStream(private->voice, true);
+	AESND_SetVoiceStop(private->voice, 0);
+	AESND_Pause(0);
+
+	current = private;
+	return 1;
+}
+
+static int OGCAUD_OpenAudio(_THIS, SDL_AudioSpec *spec)
+{
+	u32 format;
+	ogcAudio *private = (ogcAudio*)(this->hidden);
+
+	if (spec->freq <= 0 || spec->freq > 144000)
+		spec->freq = DSP_DEFAULT_FREQ;
+
+	// default sample size = 1 byte (1 channel @ 8 bits)
+	spec->samples = DMA_BUFFER_SIZE;
+
+	// no support for little endian or 16 bit unsigned
+	switch (spec->format) {
+		case AUDIO_U8:
+			format = VOICE_MONO8_UNSIGNED;
+			break;
+		case AUDIO_S8:
+			format = VOICE_MONO8;
+			break;
+		// anything else needs conversion to signed 16 big-endian
+		default:
+		case AUDIO_U16LSB:
+		case AUDIO_U16MSB:
+		case AUDIO_S16LSB:
+			spec->format = AUDIO_S16MSB;
+			// fallthrough
+		case AUDIO_S16MSB:
+			format = VOICE_MONO16;
+			// samples are 16 bits
+			spec->samples >>= 1;
+	}
+
+	// support 2 channels max
+	if (spec->channels > 2)
+		spec->channels = 2;
+
+	if (spec->channels == 2) {
+		++format;
+		// 2 values for each sample
+		spec->samples >>= 1;
+	}
+
+	spec->padding	= 0;
+	SDL_CalculateAudioSpec(spec);
+
+	private->format = format;
+	// AESND will convert frequency as required
+	private->freq = spec->freq;
+
+	return OGC_AudioStart(private);
+}
+
+static void OGCAUD_CloseAudio(_THIS)
+{
+	OGC_AudioStop((ogcAudio*)(this->hidden));
+	current = NULL;
+}
+
+static void OGCAUD_DeleteDevice(_THIS)
+{
+	OGC_AudioStop((ogcAudio*)(this->hidden));
+
+	free(this->hidden);
+	SDL_free(this);
+}
+
+static SDL_AudioDevice *OGCAUD_CreateDevice(int devindex)
+{
+	SDL_AudioDevice *this;
+
+	athread = LWP_THREAD_NULL;
+
+	/* Initialize all variables that we clean on shutdown */
+	this = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
+	if ( this ) {
+		SDL_memset(this, 0, (sizeof *this));
+		this->hidden = (ogcAudio*)memalign(32, sizeof(ogcAudio));
+	}
+	if ( (this == NULL) || (this->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		SDL_free(this);
+		return NULL;
+	}
+	SDL_memset(this->hidden, 0, sizeof(ogcAudio));
+
+	// Initialise the ogc side of the audio system
+	AESND_Init();
+	AESND_Pause(1);
+
+	/* Set the function pointers */
+	this->OpenAudio = OGCAUD_OpenAudio;
+	//this->WaitAudio = WIIAUD_WaitAudio;
+	//this->PlayAudio = WIIAUD_PlayAudio;
+	//this->GetAudioBuf = WIIAUD_GetAudioBuf;
+	this->CloseAudio = OGCAUD_CloseAudio;
+	this->free = OGCAUD_DeleteDevice;
+
+	return this;
+}
+
+static int OGCAUD_Available(void)
+{
+	return 1;
+}
+
+AudioBootStrap OGCAUD_bootstrap = {
+	OGCAUD_DRIVER_NAME, "SDL ogc audio driver",
+	OGCAUD_Available, OGCAUD_CreateDevice
+};
diff --git a/src/audio/ogc/SDL_ogcAudio.h b/src/audio/ogc/SDL_ogcAudio.h
new file mode 100644
index 0000000000..532db57424
--- /dev/null
+++ b/src/audio/ogc/SDL_ogcAudio.h
@@ -0,0 +1,49 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifndef _SDL_ogcAudio_h
+#define _SDL_ogcAudio_h
+
+#include <ogcsys.h>
+#include <aesndlib.h>
+
+#include "../SDL_sysaudio.h"
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_AudioDevice *this
+
+#define AUDIOSTACK 8192
+#define SAMPLES_PER_DMA_BUFFER (DSP_STREAMBUFFER_SIZE)
+
+typedef struct SDL_PrivateAudioData {
+    // these go first so they will be aligned
+    Uint8 astack[AUDIOSTACK];
+    short dma_buffers[2][SAMPLES_PER_DMA_BUFFER*2];
+
+    AESNDPB* voice;
+    u32 format;
+    u32 freq;
+    volatile bool stopaudio;
+} ogcAudio;
+
+#endif /* _SDL_dummyaudio_h */
diff --git a/src/joystick/ogc/SDL_sysjoystick.c b/src/joystick/ogc/SDL_sysjoystick.c
new file mode 100644
index 0000000000..1ecf6df0ad
--- /dev/null
+++ b/src/joystick/ogc/SDL_sysjoystick.c
@@ -0,0 +1,796 @@
+/*
+ SDL - Simple DirectMedia Layer
+ Copyright (C) 1997-2006 Sam Lantinga
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+ Sam Lantinga
+ slouken@libsdl.org
+ */
+#include "SDL_config.h"
+
+#ifdef SDL_JOYSTICK_OGC
+
+#include "SDL_events.h"
+#include "SDL_joystick.h"
+#include "../SDL_sysjoystick.h"
+#include "../SDL_joystick_c.h"
+
+#include <gccore.h>
+#include <unistd.h>
+#include <wiiuse/wpad.h>
+#include <math.h>
+
+#define MAX_GC_JOYSTICKS	4
+#define MAX_WII_JOYSTICKS	4
+
+#ifdef __wii__
+#define MAX_JOYSTICKS		(MAX_GC_JOYSTICKS + MAX_WII_JOYSTICKS)
+#else
+#define MAX_JOYSTICKS		MAX_GC_JOYSTICKS
+#endif
+
+#define MAX_GC_AXES			6
+#define MAX_GC_BUTTONS		8
+#define	MAX_GC_HATS			1
+
+#define MAX_WII_AXES		9
+#define MAX_WII_BUTTONS		15
+#define	MAX_WII_HATS		1
+
+#define	JOYNAMELEN			10
+
+#define AXIS_MIN	-32767  /* minimum value for axis coordinate */
+#define AXIS_MAX	32767   /* maximum value for axis coordinate */
+
+extern SDL_Joystick **SDL_joysticks;
+
+typedef struct joystick_paddata_t
+{
+	u16 prev_buttons;
+	s8 stickX;
+	s8 stickY;
+	s8 substickX;
+	s8 substickY;
+	u8 triggerL;
+	u8 triggerR;
+}joystick_paddata;
+
+typedef struct joystick_wpaddata_t
+{
+	u32 prev_buttons;
+	u32 exp;
+	s16 nunchuk_stickX;
+	s16 nunchuk_stickY;
+	s16 classicL_stickX;
+	s16 classicL_stickY;
+	s16 classicR_stickX;
+	s16 classicR_stickY;
+	u8 classic_triggerL;
+	u8 classic_triggerR;
+	u8 classic_calibrated;
+	s8 wiimote_pitch;
+	s8 wiimote_roll;
+	s8 wiimote_yaw;
+	s16 classic_cal[4][3]; // 4x axes, min/center/max
+}joystick_wpaddata;
+
+static const u16 sdl_buttons_gc[] =
+{
+	PAD_BUTTON_A,
+	PAD_BUTTON_B,
+	PAD_BUTTON_X,
+	PAD_BUTTON_Y,
+	PAD_TRIGGER_L,
+	PAD_TRIGGER_R,
+	PAD_TRIGGER_Z,
+	PAD_BUTTON_START,
+};
+
+/* The private structure used to keep track of a joystick */
+typedef struct joystick_hwdata_t
+{
+	int index;
+	int type;
+#ifdef __wii__
+	union
+	{
+		joystick_paddata gamecube;
+		joystick_wpaddata wiimote;
+	};
+#else
+	joystick_paddata gamecube;
+#endif
+} joystick_hwdata;
+
+static const int __jspad_enabled = 1;
+static const int __numgcjoysticks = 4;
+
+#ifdef __wii__
+#define GC_JOYSTICK_FROM_INDEX(index) (index - num_wii_joysticks)
+#else
+#define GC_JOYSTICK_FROM_INDEX(index) (index)
+#endif
+
+#ifdef __wii__
+static const int __jswpad_enabled = 1;
+static const int __numwiijoysticks = 4;
+static int split_joysticks = 0;
+static int num_wii_joysticks;
+
+static const u32 sdl_buttons_wii[] =
+{
+	WPAD_BUTTON_A|WPAD_CLASSIC_BUTTON_A,
+	WPAD_BUTTON_B|WPAD_CLASSIC_BUTTON_B,
+	WPAD_BUTTON_1,
+	WPAD_BUTTON_2,
+	WPAD_BUTTON_MINUS|WPAD_CLASSIC_BUTTON_MINUS,
+	WPAD_BUTTON_PLUS|WPAD_CLASSIC_BUTTON_PLUS,
+	WPAD_BUTTON_HOME|WPAD_CLASSIC_BUTTON_HOME,
+	WPAD_NUNCHUK_BUTTON_Z, /* 7 */
+	WPAD_NUNCHUK_BUTTON_C, /* 8 */
+	WPAD_CLASSIC_BUTTON_X, /* 9 */
+	WPAD_CLASSIC_BUTTON_Y,
+	WPAD_CLASSIC_BUTTON_FULL_L,
+	WPAD_CLASSIC_BUTTON_FULL_R,
+	WPAD_CLASSIC_BUTTON_ZL,
+	WPAD_CLASSIC_BUTTON_ZR
+};
+#define SDL_WII_NUM_BUTTONS_WII \
+	(sizeof(sdl_buttons_wii) / sizeof(sdl_buttons_wii[0]))
+
+static const u32 sdl_buttons_wiimote[] =
+{
+	WPAD_BUTTON_A,
+	WPAD_BUTTON_B,
+	WPAD_BUTTON_1,
+	WPAD_BUTTON_2,
+	WPAD_BUTTON_MINUS,
+	WPAD_BUTTON_PLUS,
+	WPAD_BUTTON_HOME,
+};
+#define SDL_WII_NUM_BUTTONS_WIIMOTE \
+	(sizeof(sdl_buttons_wiimote) / sizeof(sdl_buttons_wiimote[0]))
+
+static const u32 sdl_buttons_nunchuck[] =
+{
+	WPAD_NUNCHUK_BUTTON_Z,
+	WPAD_NUNCHUK_BUTTON_C,
+};
+#define SDL_WII_NUM_BUTTONS_NUNCHUCK \
+	(sizeof(sdl_buttons_nunchuck) / sizeof(sdl_buttons_nunchuck[0]))
+
+static const u32 sdl_buttons_classic[] =
+{
+	WPAD_CLASSIC_BUTTON_A,
+	WPAD_CLASSIC_BUTTON_B,
+	WPAD_CLASSIC_BUTTON_X,
+	WPAD_CLASSIC_BUTTON_Y,
+	WPAD_CLASSIC_BUTTON_FULL_L,
+	WPAD_CLASSIC_BUTTON_FULL_R,
+	WPAD_CLASSIC_BUTTON_ZL,
+	WPAD_CLASSIC_BUTTON_ZR,
+	WPAD_CLASSIC_BUTTON_MINUS,
+	WPAD_CLASSIC_BUTTON_PLUS,
+	WPAD_CLASSIC_BUTTON_HOME,
+};
+#define SDL_WII_NUM_BUTTONS_CLASSIC \
+	(sizeof(sdl_buttons_classic) / sizeof(sdl_buttons_classic[0]))
+
+/* Helpers to separate nunchuk vs classic buttons which share the
+ * same scan codes. In particular, up on the classic controller is
+ * the same as Z on the nunchuk. The numbers refer to the sdl_buttons_wii
+ * list above. */
+static int wii_button_is_nunchuk(int idx)
+{
+	return idx == 7 || idx == 8;
+}
+
+static int wii_button_is_classic(int idx)
+{
+	return idx >= 9;
+}
+
+static s16 WPAD_Orient(WPADData *data, int motion)
+{
+	float out;
+
+	if (motion == 0)
+		out = data->orient.pitch;
+	else if (motion == 1)
+		out = data->orient.roll;
+	else
+		out = data->orient.yaw;
+
+	return (s16)((out / 180.0) * 128.0);
+}
+
+static s16 WPAD_Pitch(WPADData *data)
+{
+	return WPAD_Orient(data, 0);
+}
+
+static s16 WPAD_Roll(WPADData *data)
+{
+	return WPAD_Orient(data, 1);
+}
+
+static s16 WPAD_Yaw(WPADData *data)
+{
+	return WPAD_Orient(data, 2);
+}
+
+static s16 WPAD_Stick(s16 x, s16 min, s16 center, s16 max, int flip)
+{
+	s16 d;
+	int ret;
+
+	x -= center;
+
+	if (x < 0)
+		d = center - min;
+	else
+		d = max - center;
+
+	if (center - min < 5) return 0;
+	if (max - center < 5) return 0;
+
+	if (d)
+		ret = (x << 15) / d;
+	else
+		return 0;
+
+	if (flip)
+		ret = -ret;
+
+	if (ret < AXIS_MIN)
+		ret = AXIS_MIN;
+	else if (ret > AXIS_MAX)
+		ret = AXIS_MAX;
+
+	return ret;
+}
+
+static const u32 _buttons[8] = {
+	// wiimote
+	WPAD_BUTTON_UP,
+	WPAD_BUTTON_DOWN,
+	WPAD_BUTTON_LEFT,
+	WPAD_BUTTON_RIGHT,
+	// classic
+	WPAD_CLASSIC_BUTTON_UP,
+	WPAD_CLASSIC_BUTTON_DOWN,
+	WPAD_CLASSIC_BUTTON_LEFT,
+	WPAD_CLASSIC_BUTTON_RIGHT
+};
+
+static void HandleWiiHats(SDL_Joystick *joystick,
+                          const u32 changed, const u32 pressed,
+                          const u32 *buttons)
+{
+	if (changed & (buttons[0]|buttons[1]|buttons[2]|buttons[3]))
+	{
+		int hat = SDL_HAT_CENTERED;
+
+		if (pressed & buttons[0]) hat |= SDL_HAT_UP;
+		if (pressed & buttons[1]) hat |= SDL_HAT_DOWN;
+		if (pressed & buttons[2]) hat |= SDL_HAT_LEFT;
+		if (pressed & buttons[3]) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+}
+
+static void HandleWiiButtons(SDL_Joystick *joystick,
+                             const u32 changed,
+                             const WPADData *data,
+                             const u32 *buttons,
+                             size_t num_buttons)
+{
+	for (int i = 0; i < num_buttons; i++)
+	{
+		if (changed & buttons[i])
+		{
+			if (!split_joysticks &&
+				((data->exp.type == WPAD_EXP_CLASSIC && wii_button_is_nunchuk(i)) ||
+				(data->exp.type == WPAD_EXP_NUNCHUK && wii_button_is_classic(i))))
+				continue;
+
+			SDL_PrivateJoystickButton(joystick, i,
+				(data->btns_d & buttons[i]) ? SDL_PRESSED : SDL_RELEASED);
+		}
+	}
+}
+
+static void HandleWiiMotion(SDL_Joystick* joystick,
+							joystick_hwdata *prev_state,
+							WPADData *data,
+							int start_index)
+{
+	int axis = WPAD_Pitch(data);
+	if(prev_state->wiimote.wiimote_pitch != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, start_index, -(axis << 8));
+		prev_state->wiimote.wiimote_pitch = axis;
+	}
+	axis = WPAD_Roll(data);
+	if(prev_state->wiimote.wiimote_roll != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, start_index + 1, axis << 8);
+		prev_state->wiimote.wiimote_roll = axis;
+	}
+	axis = WPAD_Yaw(data);
+	if(prev_state->wiimote.wiimote_yaw != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, start_index + 2, axis << 8);
+		prev_state->wiimote.wiimote_yaw = axis;
+	}
+}
+
+static void _HandleWiiJoystickUpdate(SDL_Joystick* joystick)
+{
+	u32 changed, pressed;
+	int axis, index;
+	joystick_hwdata *prev_state;
+	WPADData *data;
+	SDL_Joystick *joy_wiimote = NULL;
+	SDL_Joystick *joy_expansion = NULL;
+
+	prev_state = (joystick_hwdata*)joystick->hwdata;
+	index = prev_state->index;
+	if (!WPAD_ReadPending(index, NULL))
+		return;
+	data = WPAD_Data(index);
+	changed = data->btns_d | data->btns_u;
+	pressed = data->btns_d | data->btns_h;
+
+	if (joystick->index >= __numwiijoysticks) {
+		/* we can get here if using the split joystick feature. But even in
+		 * that case, we don't want to do anything here: the update operation
+		 * on the wiimote must update the expansion joystick too. */
+		return;
+	}
+
+	if (split_joysticks) {
+		/* To find out the pointer to the linked joystick we use the knowledge
+		 * that the SDL_Joystick structures are allocated in a continuous array
+		 */
+		joy_wiimote = joystick;
+		joy_expansion = SDL_joysticks[joystick->index + 4];
+	}
+
+	if (split_joysticks) {
+		HandleWiiHats(joy_wiimote, changed, pressed, _buttons);
+		if (data->exp.type == WPAD_EXP_CLASSIC) { // classic controller
+			HandleWiiHats(joy_expansion, changed, pressed, _buttons + 4);
+		}
+	} else {
+		if (data->exp.type == WPAD_EXP_CLASSIC) // classic controller
+			HandleWiiHats(joystick, changed, pressed, _buttons + 4);
+		HandleWiiHats(joystick, changed, pressed, _buttons);
+	}
+
+	if (split_joysticks) {
+		HandleWiiButtons(joy_wiimote, changed, data,
+						 sdl_buttons_wiimote, SDL_WII_NUM_BUTTONS_WIIMOTE);
+		if (data->exp.type == WPAD_EXP_CLASSIC) {
+			HandleWiiButtons(joy_expansion, changed, data,
+							 sdl_buttons_classic, SDL_WII_NUM_BUTTONS_CLASSIC);
+		} else if (data->exp.type == WPAD_EXP_NUNCHUK) {
+			HandleWiiButtons(joy_expansion, changed, data,
+							 sdl_buttons_nunchuck, SDL_WII_NUM_BUTTONS_NUNCHUCK);
+		}
+	} else {
+		HandleWiiButtons(joystick, changed, data,
+						 sdl_buttons_wii, SDL_WII_NUM_BUTTONS_WII);
+	}
+
+	if(data->exp.type == WPAD_EXP_CLASSIC)
+	{
+		if (prev_state->wiimote.exp != WPAD_EXP_CLASSIC)
+		{
+			prev_state->wiimote.classic_calibrated = 0;
+			prev_state->wiimote.classic_cal[0][0] = 5;  // left x min
+			prev_state->wiimote.classic_cal[0][2] = 59; // left x max
+			prev_state->wiimote.classic_cal[1][0] = 5; // left y min
+			prev_state->wiimote.classic_cal[1][2] = 59;  // left y max
+			prev_state->wiimote.classic_cal[2][0] = 5;  // right x min
+			prev_state->wiimote.classic_cal[2][2] = 27; // right x max
+			prev_state->wiimote.classic_cal[3][0] = 5; // right y min
+			prev_state->wiimote.classic_cal[3][2] = 27;  // right y max
+
+		}
+
+		// max/min checking
+		// left stick x
+		if (data->exp.classic.ljs.pos.x < prev_state->wiimote.classic_cal[0][0])
+			prev_state->wiimote.classic_cal[0][0] = data->exp.classic.ljs.pos.x;
+		else if (data->exp.classic.ljs.pos.x > prev_state->wiimote.classic_cal[0][2])
+			prev_state->wiimote.classic_cal[0][2] = data->exp.classic.ljs.pos.x;
+		// left stick y
+		if (data->exp.classic.ljs.pos.y < prev_state->wiimote.classic_cal[1][0])
+			prev_state->wiimote.classic_cal[1][0] = data->exp.classic.ljs.pos.y;
+		else if (data->exp.classic.ljs.pos.y > prev_state->wiimote.classic_cal[1][2])
+			prev_state->wiimote.classic_cal[1][2] = data->exp.classic.ljs.pos.y;
+		// right stick x
+		if (data->exp.classic.rjs.pos.x < prev_state->wiimote.classic_cal[2][0])
+			prev_state->wiimote.classic_cal[2][0] = data->exp.classic.rjs.pos.x;
+		else if (data->exp.classic.rjs.pos.x > prev_state->wiimote.classic_cal[2][2])
+			prev_state->wiimote.classic_cal[2][2] = data->exp.classic.rjs.pos.x;
+		// right stick y
+		if (data->exp.classic.rjs.pos.y < prev_state->wiimote.classic_cal[3][0])
+			prev_state->wiimote.classic_cal[3][0] = data->exp.classic.rjs.pos.y;
+		else if (data->exp.classic.rjs.pos.y > prev_state->wiimote.classic_cal[3][2])
+			prev_state->wiimote.classic_cal[3][2] = data->exp.classic.rjs.pos.y;
+
+		// calibrate center positions
+		if (prev_state->wiimote.classic_calibrated < 5)
+		{
+			prev_state->wiimote.classic_cal[0][1] = data->exp.classic.ljs.pos.x;
+			prev_state->wiimote.classic_cal[1][1] = data->exp.classic.ljs.pos.y;
+			prev_state->wiimote.classic_cal[2][1] = data->exp.classic.rjs.pos.x;
+			prev_state->wiimote.classic_cal[3][1] = data->exp.classic.rjs.pos.y;
+			// this is zero if the expansion hasn't finished initializing
+			if (data->exp.classic.ljs.max.x)
+				prev_state->wiimote.classic_calibrated++;
+		}
+	}
+
+	if (data->exp.type != prev_state->wiimote.exp)
+	{
+		SDL_Joystick *joy = split_joysticks ? joy_expansion : joystick;
+		// Reset the expansion axes
+		for (int i = 0; i < 6; i++)
+			SDL_PrivateJoystickAxis(joy, i, 0);
+	}
+
+	if(data->exp.type == WPAD_EXP_CLASSIC)
+	{
+		SDL_Joystick *joy = split_joysticks ? joy_expansion : joystick;
+
+		axis = WPAD_Stick(data->exp.classic.ljs.pos.x, prev_state->wiimote.classic_cal[0][0],
+			prev_state->wiimote.classic_cal[0][1], prev_state->wiimote.classic_cal[0][2], 0);
+		if(prev_state->wiimote.classicL_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 0, axis);
+			prev_state->wiimote.classicL_stickX = axis;
+		}
+		// y axes are reversed
+		axis = WPAD_Stick(data->exp.classic.ljs.pos.y, prev_state->wiimote.classic_cal[1][0],
+			prev_state->wiimote.classic_cal[1][1], prev_state->wiimote.classic_cal[1][2], 1);
+		if(prev_state->wiimote.classicL_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 1, axis);
+			prev_state->wiimote.classicL_stickY = axis;
+		}
+		axis = WPAD_Stick(data->exp.classic.rjs.pos.x, prev_state->wiimote.classic_cal[2][0],
+			prev_state->wiimote.classic_cal[2][1], prev_state->wiimote.classic_cal[2][2], 0);
+		if(prev_state->wiimote.classicR_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 2, axis);
+			prev_state->wiimote.classicR_stickX = axis;
+		}
+		axis = WPAD_Stick(data->exp.classic.rjs.pos.y, prev_state->wiimote.classic_cal[3][0],
+			prev_state->wiimote.classic_cal[3][1], prev_state->wiimote.classic_cal[3][2], 1);
+		if(prev_state->wiimote.classicR_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 3, axis);
+			prev_state->wiimote.classicR_stickY = axis;
+		}
+		axis = data->exp.classic.r_shoulder;
+		if(prev_state->wiimote.classic_triggerR != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 4, axis<<8);
+			prev_state->wiimote.classic_triggerR = axis;
+		}
+		axis = data->exp.classic.l_shoulder;
+		if(prev_state->wiimote.classic_triggerL != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 5, axis<<8);
+			prev_state->wiimote.classic_triggerL = axis;
+		}
+	}
+	else if(data->exp.type == WPAD_EXP_NUNCHUK)
+	{
+		SDL_Joystick *joy = split_joysticks ? joy_expansion : joystick;
+
+		axis = WPAD_Stick(data->exp.nunchuk.js.pos.x, data->exp.nunchuk.js.min.x,
+			data->exp.nunchuk.js.center.x, data->exp.nunchuk.js.max.x, 0);
+		if(prev_state->wiimote.nunchuk_stickX != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 0, axis);
+			prev_state->wiimote.nunchuk_stickX = axis;
+		}
+		axis = WPAD_Stick(data->exp.nunchuk.js.pos.y, data->exp.nunchuk.js.min.y,
+			data->exp.nunchuk.js.center.y, data->exp.nunchuk.js.max.y, 1);
+		if(prev_state->wiimote.nunchuk_stickY != axis)
+		{
+			SDL_PrivateJoystickAxis(joy, 1, axis);
+			prev_state->wiimote.nunchuk_stickY = axis;
+		}
+	}
+
+	prev_state->wiimote.exp = data->exp.type;
+
+	if (split_joysticks) {
+		// also update the expansion
+		((joystick_hwdata*)joy_expansion->hwdata)->wiimote.exp = data->exp.type;
+	}
+
+	int start_index = split_joysticks ? 0 : 6;
+	HandleWiiMotion(split_joysticks ? joy_wiimote : joystick, prev_state, data, start_index);
+}
+
+#endif
+
+/* Function to scan the system for joysticks.
+ * This function should return the number of available
+ * joysticks.  Joystick 0 should be the system default joystick.
+ * It should return -1 on an unrecoverable fatal error.
+ */
+int SDL_SYS_JoystickInit(void)
+{
+#ifdef __wii__
+	const char *split_joystick_env = getenv("SDL_WII_JOYSTICK_SPLIT");
+	split_joysticks = split_joystick_env && strcmp(split_joystick_env, "1") == 0;
+	/* Multiply by two because each wiimote might have an expansion connected */
+	num_wii_joysticks = split_joysticks ? __numwiijoysticks * 2 : __numwiijoysticks;
+	return num_wii_joysticks + __numgcjoysticks;
+#else
+	return MAX_JOYSTICKS;
+#endif
+}
+
+static char joy_name[64] = "Gamecube 0";
+
+/* Function to get the device-dependent name of a joystick */
+const char *SDL_SYS_JoystickName(int index)
+{
+	if(index>=0) {
+#ifdef __wii__
+		if((__jswpad_enabled) && (index < num_wii_joysticks)) {
+			joystick_hwdata *hwdata = (joystick_hwdata*)SDL_joysticks[index]->hwdata;
+			char *name_ptr = joy_name;
+			if (index < __numwiijoysticks) {
+				name_ptr += sprintf(name_ptr, "Wiimote %d", index);
+				if (!split_joysticks) {
+				    // Add expansion information
+					switch (hwdata->wiimote.exp) {
+					case WPAD_EXP_NUNCHUK:
+						strcpy(name_ptr, " + Nunchuk"); break;
+					case WPAD_EXP_CLASSIC:
+						strcpy(name_ptr, " + Classic"); break;
+					case WPAD_EXP_GUITARHERO3:
+						strcpy(name_ptr, " + Guitar Hero 3"); break;
+					case WPAD_EXP_WIIBOARD:
+						strcpy(name_ptr, " + Balance board"); break;
+					}
+				}
+			} else {
+				/* This is an expansion and we are using the split controllers
+				 * option: show only the expansion name, then. */
+				int idx = index - __numwiijoysticks;
+				switch (hwdata->wiimote.exp) {
+				case WPAD_EXP_NUNCHUK:
+					sprintf(name_ptr, "Nunchuk %d", idx); break;
+				case WPAD_EXP_CLASSIC:
+					sprintf(name_ptr, "Classic %d", idx); break;
+				case WPAD_EXP_GUITARHERO3:
+					sprintf(name_ptr, "Guitar Hero 3 %d", idx); break;
+				case WPAD_EXP_WIIBOARD:
+					sprintf(name_ptr, "Balance board %d", idx); break;
+				case WPAD_EXP_NONE:
+					strcpy(name_ptr, "Disconnected"); break;
+				default:
+					sprintf(name_ptr, "Unknown %d", idx); break;
+				}
+			}
+		} else if((__jspad_enabled) && (index < (num_wii_joysticks + __numgcjoysticks)))
+#endif
+			sprintf(joy_name, "Gamecube %d", index);
+	}
+	return (const char *)joy_name;
+}
+
+/* Function to open a joystick for use.
+ The joystick to open is specified by the index field of the joystick.
+ This should fill the nbuttons and naxes fields of the joystick structure.
+ It returns 0, or -1 if there is an error.
+ */
+int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
+{
+	/* allocate memory for system specific hardware data */
+	joystick->hwdata = SDL_malloc(sizeof(joystick_hwdata));
+	if (joystick->hwdata == NULL)
+	{
+		SDL_OutOfMemory();
+		return(-1);
+	}
+	SDL_memset(joystick->hwdata, 0, sizeof(joystick_hwdata));
+#ifdef __wii__
+	if((joystick->index < num_wii_joysticks) && (__jswpad_enabled))
+	{
+		int index = (joystick->index > __numwiijoysticks) ? (joystick->index - __numwiijoysticks) : joystick->index;
+		((joystick_hwdata*)(joystick->hwdata))->index = index;
+		((joystick_hwdata*)(joystick->hwdata))->type = 0;
+		if (split_joysticks) {
+			if (joystick->index < __numwiijoysticks) {
+				// wiimote
+				joystick->nbuttons = SDL_WII_NUM_BUTTONS_WIIMOTE;
+				joystick->naxes = 3;
+				joystick->nhats = 1;
+			} else {
+				// expansion
+				joystick->nbuttons = SDL_max(SDL_WII_NUM_BUTTONS_NUNCHUCK,
+				                             SDL_WII_NUM_BUTTONS_CLASSIC);
+				joystick->naxes = 6;
+				joystick->nhats = 1;
+			}
+		} else {
+			joystick->nbuttons = MAX_WII_BUTTONS;
+			joystick->naxes = MAX_WII_AXES;
+			joystick->nhats = MAX_WII_HATS;
+		}
+	}
+	else if((joystick->index < num_wii_joysticks + __numgcjoysticks) && (__jspad_enabled))
+	{
+		((joystick_hwdata*)(joystick->hwdata))->index = joystick->index - num_wii_joysticks;
+		((joystick_hwdata*)(joystick->hwdata))->type = 1;
+		joystick->nbuttons = MAX_GC_BUTTONS;
+		joystick->naxes = MAX_GC_AXES;
+		joystick->nhats = MAX_GC_HATS;
+	}
+#else
+	if((joystick->index < 4) && (__jspad_enabled))
+	{
+		if(joystick->index < (__numgcjoysticks))
+		{
+			((joystick_hwdata*)(joystick->hwdata))->index = joystick->index - 4;
+			((joystick_hwdata*)(joystick->hwdata))->type = 1;
+			joystick->nbuttons = MAX_GC_BUTTONS;
+			joystick->naxes = MAX_GC_AXES;
+			joystick->nhats = MAX_GC_HATS;
+		}
+	}
+#endif
+	return(0);
+}
+
+
+static void _HandleGCJoystickUpdate(SDL_Joystick* joystick)
+{
+	u16 buttons, prev_buttons, changed;
+	int i;
+	int axis;
+	joystick_hwdata *prev_state;
+	int index = GC_JOYSTICK_FROM_INDEX(joystick->index);
+
+	buttons = PAD_ButtonsHeld(index);
+	prev_state = (joystick_hwdata *)joystick->hwdata;
+	prev_buttons = prev_state->gamecube.prev_buttons;
+	changed = buttons ^ prev_buttons;
+
+	if(changed & (PAD_BUTTON_LEFT | PAD_BUTTON_RIGHT | PAD_BUTTON_DOWN | PAD_BUTTON_UP))
+	{
+		int hat = SDL_HAT_CENTERED;
+		if(buttons & PAD_BUTTON_UP) hat |= SDL_HAT_UP;
+		if(buttons & PAD_BUTTON_DOWN) hat |= SDL_HAT_DOWN;
+		if(buttons & PAD_BUTTON_LEFT) hat |= SDL_HAT_LEFT;
+		if(buttons & PAD_BUTTON_RIGHT) hat |= SDL_HAT_RIGHT;
+		SDL_PrivateJoystickHat(joystick, 0, hat);
+	}
+
+	for(i = 0; i < (sizeof(sdl_buttons_gc) / sizeof(sdl_buttons_gc[0])); i++)
+	{
+		if (changed & sdl_buttons_gc[i])
+			SDL_PrivateJoystickButton(joystick, i,
+				(buttons & sdl_buttons_gc[i]) ? SDL_PRESSED : SDL_RELEASED);
+	}
+	prev_state->gamecube.prev_buttons = buttons;
+	axis = PAD_StickX(index);
+	if(prev_state->gamecube.stickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 0, axis << 8);
+		prev_state->gamecube.stickX = axis;
+	}
+
+	axis = PAD_StickY(index);
+	if(prev_state->gamecube.stickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 1, (-axis) << 8);
+		prev_state->gamecube.stickY = axis;
+	}
+
+	axis = PAD_SubStickX(index);
+	if(prev_state->gamecube.substickX != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 2, axis << 8);
+		prev_state->gamecube.substickX = axis;
+	}
+
+	axis = PAD_SubStickY(index);
+	if(prev_state->gamecube.substickY != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 3, (-axis) << 8);
+		prev_state->gamecube.substickY = axis;
+	}
+
+	axis = PAD_TriggerL(index);
+	if(prev_state->gamecube.triggerL != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 4, axis << 7);
+		prev_state->gamecube.triggerL = axis;
+	}
+
+	axis = PAD_TriggerR(index);
+	if(prev_state->gamecube.triggerR != axis)
+	{
+		SDL_PrivateJoystickAxis(joystick, 5, axis << 7);
+		prev_state->gamecube.triggerR = axis;
+	}
+}
+
+/* Function to update the state of a joystick - called as a device poll.
+ * This function shouldn't update the joystick structure directly,
+ * but instead should call SDL_PrivateJoystick*() to deliver events
+ * and update joystick device state.
+ */
+
+void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata)
+		return;
+
+	PAD_ScanPads();
+
+	switch(((joystick_hwdata*)(joystick->hwdata))->type)
+	{
+#ifdef __wii__
+		case 0:
+			if(__jswpad_enabled) {
+				if (split_joysticks && joystick->index >= __numwiijoysticks) {
+					/* the actual joystick we want to update is always the wiimote
+					 * one */
+					joystick = SDL_joysticks[joystick->index - __numwiijoysticks];
+				}
+				_HandleWiiJoystickUpdate(joystick);
+            }
+			break;
+#endif
+		case 1:
+			if(__jspad_enabled)
+				_HandleGCJoystickUpdate(joystick);
+			break;
+		default:
+			break;
+	}
+}
+
+/* Function to close a joystick after use */
+void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
+{
+	if(!joystick || !joystick->hwdata) // joystick already closed
+		return;
+
+	SDL_free(joystick->hwdata);
+	joystick->hwdata = NULL;
+}
+
+/* Function to perform any system-specific joystick related cleanup */
+void SDL_SYS_JoystickQuit(void)
+{
+
+}
+
+#endif /* SDL_JOYSTICK_DC */
diff --git a/src/main/gamecube/SDL_gamecube_main.c b/src/main/gamecube/SDL_gamecube_main.c
new file mode 100644
index 0000000000..1ad5a19bd5
--- /dev/null
+++ b/src/main/gamecube/SDL_gamecube_main.c
@@ -0,0 +1,26 @@
+/* Include the SDL main definition header */
+#include "SDL_main.h"
+#undef main
+
+/* Standard includes */
+#include <stdio.h>
+
+/* SDL includes */
+#include "../../video/ogc/SDL_ogc_video.h"
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+//	SYS_SetPowerCallback(ShutdownCB);
+//	SYS_SetResetCallback(ResetCB);
+	PAD_Init();
+	OGC_InitVideoSystem();
+	fatInitDefault();
+	/* Call the user's main function */
+	return(SDL_main(argc, argv));
+}
diff --git a/src/main/wii/SDL_wii_main.c b/src/main/wii/SDL_wii_main.c
new file mode 100644
index 0000000000..297be85622
--- /dev/null
+++ b/src/main/wii/SDL_wii_main.c
@@ -0,0 +1,76 @@
+/* Include the SDL main definition header */
+#include "SDL_main.h"
+#undef main
+
+/* Standard includes */
+#include <stdio.h>
+
+/* SDL includes */
+#include "../../video/ogc/SDL_ogc_video.h"
+
+/* OGC includes */
+#include <fat.h>
+#include <ogcsys.h>
+#include <wiiuse/wpad.h>
+#include <ogc/usbmouse.h>
+#include <wiikeyboard/keyboard.h>
+
+bool TerminateRequested=false, ShutdownRequested=false, ResetRequested=false;
+
+void SDL_Quit();
+static void ShutdownCB()
+{
+	TerminateRequested = 1;
+	ShutdownRequested = 1;
+}
+static void ResetCB()
+{
+	TerminateRequested = 1;
+	ResetRequested = 1;
+}
+void ShutdownWii()
+{
+	TerminateRequested = 0;
+	SDL_Quit();
+	SYS_ResetSystem(SYS_POWEROFF, 0, 0);
+}
+void RestartHomebrewChannel()
+{
+	TerminateRequested = 0;
+	SDL_Quit();
+	exit(1);
+}
+void Terminate()
+{
+	if (ShutdownRequested) ShutdownWii();
+	else if (ResetRequested) RestartHomebrewChannel();
+}
+
+/* Do initialisation which has to be done first for the console to work */
+/* Entry point */
+int main(int argc, char *argv[])
+{
+	L2Enhance();
+	u32 version = IOS_GetVersion();
+	s32 preferred = IOS_GetPreferredVersion();
+
+	if(preferred > 0 && version != (u32)preferred)
+		IOS_ReloadIOS(preferred);
+
+	// Wii Power/Reset buttons
+	WPAD_Init();
+	WPAD_SetPowerButtonCallback((WPADShutdownCallback)ShutdownCB);
+	SYS_SetPowerCallback(ShutdownCB);
+	SYS_SetResetCallback(ResetCB);
+	PAD_Init();
+	OGC_InitVideoSystem();
+	WPAD_SetDataFormat(WPAD_CHAN_ALL,WPAD_FMT_BTNS_ACC_IR);
+	WPAD_SetVRes(WPAD_CHAN_ALL, 640, 480);
+
+	MOUSE_Init();
+	KEYBOARD_Init(NULL);
+	fatInitDefault();
+	/* Call the user's main function */
+	return(SDL_main(argc, argv));
+}
+
diff --git a/src/thread/SDL_thread_c.h b/src/thread/SDL_thread_c.h
index 8af6e52f41..e2c21bd6f6 100644
--- a/src/thread/SDL_thread_c.h
+++ b/src/thread/SDL_thread_c.h
@@ -43,6 +43,8 @@
 #include "win32/SDL_systhread_c.h"
 #elif SDL_THREAD_SYMBIAN
 #include "symbian/SDL_systhread_c.h"
+#elif SDL_THREAD_OGC
+#include "ogc/SDL_systhread_c.h"
 #else
 #error Need thread implementation for this platform
 #include "generic/SDL_systhread_c.h"
diff --git a/src/thread/ogc/SDL_syscond.c b/src/thread/ogc/SDL_syscond.c
new file mode 100644
index 0000000000..70d76b97ec
--- /dev/null
+++ b/src/thread/ogc/SDL_syscond.c
@@ -0,0 +1,139 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of condition variables using semaphores and mutexes */
+/*
+   This implementation borrows heavily from the BeOS condition variable
+   implementation, written by Christopher Tate and Owen Smith.  Thanks!
+ */
+
+#include "SDL_thread.h"
+#include "SDL_sysmutex_c.h"
+
+#include <ogcsys.h>
+#include <ogc/cond.h>
+
+struct SDL_cond
+{
+	cond_t cond;
+};
+
+/* Create a condition variable */
+SDL_cond * SDL_CreateCond(void)
+{
+	SDL_cond *cond;
+
+	cond = (SDL_cond *) SDL_malloc(sizeof(SDL_cond));
+	if (cond)
+	{
+		if (LWP_CondInit(&(cond->cond)) < 0)
+		{
+			SDL_DestroyCond(cond);
+			cond = NULL;
+		}
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+	return (cond);
+}
+
+/* Destroy a condition variable */
+void SDL_DestroyCond(SDL_cond *cond)
+{
+	if (cond)
+	{
+		LWP_CondDestroy(cond->cond);
+		SDL_free(cond);
+	}
+}
+
+/* Restart one of the threads that are waiting on the condition variable */
+int SDL_CondSignal(SDL_cond *cond)
+{
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	return LWP_CondSignal(cond->cond) == 0 ? 0 : -1;
+
+}
+
+/* Restart all threads that are waiting on the condition variable */
+int SDL_CondBroadcast(SDL_cond *cond)
+{
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+
+	return LWP_CondBroadcast(cond->cond) == 0 ? 0 : -1;
+}
+
+/* Wait on the condition variable for at most 'ms' milliseconds.
+ The mutex must be locked before entering this function!
+ The mutex is unlocked during the wait, and locked again after the wait.
+
+ Typical use:
+
+ Thread A:
+ SDL_LockMutex(lock);
+ while ( ! condition ) {
+ SDL_CondWait(cond);
+ }
+ SDL_UnlockMutex(lock);
+
+ Thread B:
+ SDL_LockMutex(lock);
+ ...
+ condition = true;
+ ...
+ SDL_UnlockMutex(lock);
+ */
+
+
+int SDL_CondWaitTimeout(SDL_cond *cond, SDL_mutex *mutex, Uint32 ms)
+{
+	struct timespec time; 
+
+	if (!cond)
+	{
+		SDL_SetError("Passed a NULL condition variable");
+		return -1;
+	}
+	//LWP_CondTimedWait expects relative timeout
+	time.tv_sec = (ms / 1000);
+	time.tv_nsec = (ms % 1000) * 1000000;
+
+	return LWP_CondTimedWait(cond->cond, mutex->id, &time);
+}
+
+/* Wait on the condition variable forever */
+int SDL_CondWait(SDL_cond *cond, SDL_mutex *mutex)
+{
+	return LWP_CondWait(cond->cond, mutex->id);
+}
diff --git a/src/thread/ogc/SDL_sysmutex.c b/src/thread/ogc/SDL_sysmutex.c
new file mode 100644
index 0000000000..9fc57496c8
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex.c
@@ -0,0 +1,87 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of mutexes using semaphores */
+
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+#include <ogcsys.h>
+
+struct SDL_mutex
+{
+	u32 id;
+};
+
+/* Create a mutex */
+SDL_mutex *SDL_CreateMutex(void)
+{
+	SDL_mutex *mutex = NULL;
+
+	/* Allocate mutex memory */
+	mutex = (SDL_mutex *) SDL_malloc(sizeof(*mutex));
+	if (mutex)
+	{
+		LWP_MutexInit(&mutex->id, 0);
+	}
+	else
+	{
+		SDL_OutOfMemory();
+	}
+	return mutex;
+}
+
+/* Free the mutex */
+void SDL_DestroyMutex(SDL_mutex *mutex)
+{
+	if (mutex)
+	{
+		LWP_MutexDestroy(mutex->id);
+		SDL_free(mutex);
+	}
+}
+
+/* Lock the semaphore */
+int SDL_mutexP(SDL_mutex *mutex)
+{
+	if (mutex == NULL)
+	{
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	return LWP_MutexLock(mutex->id);
+}
+
+/* Unlock the mutex */
+int SDL_mutexV(SDL_mutex *mutex)
+{
+	if (mutex == NULL)
+	{
+		SDL_SetError("Passed a NULL mutex");
+		return -1;
+	}
+
+	return LWP_MutexUnlock(mutex->id);
+
+}
diff --git a/src/thread/ogc/SDL_sysmutex_c.h b/src/thread/ogc/SDL_sysmutex_c.h
new file mode 100644
index 0000000000..8fdac822a6
--- /dev/null
+++ b/src/thread/ogc/SDL_sysmutex_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+struct SDL_mutex {
+	Uint32 id;
+};
diff --git a/src/thread/ogc/SDL_syssem.c b/src/thread/ogc/SDL_syssem.c
new file mode 100644
index 0000000000..4c68ac3ea9
--- /dev/null
+++ b/src/thread/ogc/SDL_syssem.c
@@ -0,0 +1,175 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* An implementation of semaphores using mutexes and condition variables */
+
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+#include "SDL_systhread_c.h"
+
+struct SDL_semaphore
+{
+	Uint32 count;
+	Uint32 waiters_count;
+	SDL_mutex *count_lock;
+	SDL_cond *count_nonzero;
+};
+
+SDL_sem *SDL_CreateSemaphore(Uint32 initial_value)
+{
+	SDL_sem *sem;
+
+	sem = (SDL_sem *) SDL_malloc(sizeof(*sem));
+	if (!sem)
+	{
+		SDL_OutOfMemory();
+		return NULL;
+	}
+	sem->count = initial_value;
+	sem->waiters_count = 0;
+
+	sem->count_lock = SDL_CreateMutex();
+	sem->count_nonzero = SDL_CreateCond();
+	if (!sem->count_lock || !sem->count_nonzero)
+	{
+		SDL_DestroySemaphore(sem);
+		return NULL;
+	}
+
+	return sem;
+}
+
+/* WARNING:
+ You cannot call this function when another thread is using the semaphore.
+ */
+void SDL_DestroySemaphore(SDL_sem *sem)
+{
+	if (sem)
+	{
+		sem->count = 0xFFFFFFFF;
+		while (sem->waiters_count > 0)
+		{
+			SDL_CondSignal(sem->count_nonzero);
+			SDL_Delay(10);
+		}
+		SDL_DestroyCond(sem->count_nonzero);
+		if (sem->count_lock)
+		{
+			SDL_mutexP(sem->count_lock);
+			SDL_mutexV(sem->count_lock);
+			SDL_DestroyMutex(sem->count_lock);
+		}
+		SDL_free(sem);
+	}
+}
+
+int SDL_SemTryWait(SDL_sem *sem)
+{
+	int retval;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	retval = SDL_MUTEX_TIMEDOUT;
+	SDL_LockMutex(sem->count_lock);
+	if (sem->count > 0)
+	{
+		--sem->count;
+		retval = 0;
+	}
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWaitTimeout(SDL_sem *sem, Uint32 timeout)
+{
+	int retval;
+
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	/* A timeout of 0 is an easy case */
+	if (timeout == 0)
+	{
+		return SDL_SemTryWait(sem);
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	++sem->waiters_count;
+	retval = 0;
+	while ((sem->count == 0) && (retval != SDL_MUTEX_TIMEDOUT))
+	{
+		retval = SDL_CondWaitTimeout(sem->count_nonzero, sem->count_lock,
+				timeout);
+	}
+	--sem->waiters_count;
+	--sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return retval;
+}
+
+int SDL_SemWait(SDL_sem *sem)
+{
+	return SDL_SemWaitTimeout(sem, SDL_MUTEX_MAXWAIT);
+}
+
+Uint32 SDL_SemValue(SDL_sem *sem)
+{
+	Uint32 value;
+
+	value = 0;
+	if (sem)
+	{
+		SDL_LockMutex(sem->count_lock);
+		value = sem->count;
+		SDL_UnlockMutex(sem->count_lock);
+	}
+	return value;
+}
+
+int SDL_SemPost(SDL_sem *sem)
+{
+	if (!sem)
+	{
+		SDL_SetError("Passed a NULL semaphore");
+		return -1;
+	}
+
+	SDL_LockMutex(sem->count_lock);
+	if (sem->waiters_count > 0)
+	{
+		SDL_CondSignal(sem->count_nonzero);
+	}
+	++sem->count;
+	SDL_UnlockMutex(sem->count_lock);
+
+	return 0;
+}
diff --git a/src/thread/ogc/SDL_systhread.c b/src/thread/ogc/SDL_systhread.c
new file mode 100644
index 0000000000..c546df05d0
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread.c
@@ -0,0 +1,80 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Thread management routines for SDL */
+
+#include "SDL_thread.h"
+#include "../SDL_systhread.h"
+#include "../SDL_thread_c.h"
+
+#include <ogcsys.h>
+
+/*
+struct SDL_Thread {
+	Uint32 threadid;
+	SYS_ThreadHandle handle;
+	int status;
+	SDL_error errbuf;
+	void *data;
+};
+
+ */
+
+void *run_thread(void *data)
+{
+	SDL_RunThread(data);
+	return ((void *) 0); /* Prevent compiler warning */
+}
+
+int SDL_SYS_CreateThread(SDL_Thread *thread, void *args)
+{
+	
+	if ( LWP_CreateThread(&thread->handle, run_thread, args, 0, 0, 16) != 0 ) {
+		SDL_SetError("Not enough resources to create thread");
+		return(-1);
+	}
+	
+	return (0);
+}
+
+void SDL_SYS_SetupThread(void)
+{
+	return;
+}
+
+Uint32 SDL_ThreadID(void)
+{
+	return (Uint32) LWP_GetSelf();
+}
+
+void SDL_SYS_WaitThread(SDL_Thread *thread)
+{
+	void *v;
+	LWP_JoinThread(thread->handle, &v);
+	return;
+}
+
+void SDL_SYS_KillThread(SDL_Thread *thread)
+{
+	return;
+}
diff --git a/src/thread/ogc/SDL_systhread_c.h b/src/thread/ogc/SDL_systhread_c.h
new file mode 100644
index 0000000000..fc13572acc
--- /dev/null
+++ b/src/thread/ogc/SDL_systhread_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2004 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+/* Stub until we implement threads on this platform */
+
+typedef Uint32 SYS_ThreadHandle;
diff --git a/src/timer/ogc/SDL_systimer.c b/src/timer/ogc/SDL_systimer.c
new file mode 100644
index 0000000000..144ad38df5
--- /dev/null
+++ b/src/timer/ogc/SDL_systimer.c
@@ -0,0 +1,105 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#ifdef SDL_TIMER_OGC
+
+#include <ogc/lwp_watchdog.h>
+#include <ogc/video.h>
+
+#include "SDL_timer.h"
+#include "../SDL_timer_c.h"
+
+#include <ogcsys.h>
+
+static Uint64 start;
+
+void SDL_StartTicks(void)
+{
+	start = gettime();
+}
+
+Uint32 SDL_GetTicks (void)
+{
+	const Uint64 ticks	= gettime() - start;
+	const Uint64 ms		= ticks / TB_TIMER_CLOCK;
+	return ms;
+}
+
+void SDL_Delay (Uint32 ms)
+{
+	struct timespec elapsed, tv;
+	elapsed.tv_sec = ms/1000;
+	elapsed.tv_nsec = (ms%1000)*1000000;
+	tv.tv_sec = elapsed.tv_sec;
+	tv.tv_nsec = elapsed.tv_nsec;
+	nanosleep(&tv, &elapsed);
+}
+
+#include "SDL_thread.h"
+
+/* Data to handle a single periodic alarm */
+static int timer_alive = 0;
+static SDL_Thread *timer = NULL;
+
+static int RunTimer(void *unused)
+{
+	while ( timer_alive ) {
+		if ( SDL_timer_running ) {
+			SDL_ThreadedTimerCheck();
+		}
+		SDL_Delay(1);
+	}
+	return(0);
+}
+
+/* This is only called if the event thread is not running */
+int SDL_SYS_TimerInit(void)
+{
+	timer_alive = 1;
+	timer = SDL_CreateThread(RunTimer, NULL);
+	if ( timer == NULL )
+		return(-1);
+	return(SDL_SetTimerThreaded(1));
+}
+
+void SDL_SYS_TimerQuit(void)
+{
+	timer_alive = 0;
+	if ( timer ) {
+		SDL_WaitThread(timer, NULL);
+		timer = NULL;
+	}
+}
+
+int SDL_SYS_StartTimer(void)
+{
+	SDL_SetError("Internal logic error: threaded timer in use");
+	return(-1);
+}
+
+void SDL_SYS_StopTimer(void)
+{
+	return;
+}
+
+#endif
diff --git a/src/video/SDL_sysvideo.h b/src/video/SDL_sysvideo.h
index 436450e330..65d56a56bd 100644
--- a/src/video/SDL_sysvideo.h
+++ b/src/video/SDL_sysvideo.h
@@ -410,6 +410,9 @@ extern VideoBootStrap AALIB_bootstrap;
 #if SDL_VIDEO_DRIVER_CACA
 extern VideoBootStrap CACA_bootstrap;
 #endif
+#if SDL_VIDEO_DRIVER_OGC
+extern VideoBootStrap OGC_bootstrap;
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 extern VideoBootStrap DUMMY_bootstrap;
 #endif
diff --git a/src/video/SDL_video.c b/src/video/SDL_video.c
index 46285c990e..bf379f4b61 100644
--- a/src/video/SDL_video.c
+++ b/src/video/SDL_video.c
@@ -126,6 +126,9 @@ static VideoBootStrap *bootstrap[] = {
 #if SDL_VIDEO_DRIVER_CACA
 	&CACA_bootstrap,
 #endif
+#if SDL_VIDEO_DRIVER_OGC
+	&OGC_bootstrap,
+#endif
 #if SDL_VIDEO_DRIVER_DUMMY
 	&DUMMY_bootstrap,
 #endif
diff --git a/src/video/gamecube/SDL_gamecube_events.c b/src/video/gamecube/SDL_gamecube_events.c
new file mode 100644
index 0000000000..e44a84a9eb
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_events.c
@@ -0,0 +1,13 @@
+#include "SDL_config.h"
+
+
+#include "SDL.h"
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+
+#include "../ogc/SDL_ogc_video.h"
+#include "SDL_gamecube_events_c.h"
+
+void GAMECUBE_PumpEvents(_THIS) {}
+
+void GAMECUBE_InitOSKeymap(_THIS) {}
diff --git a/src/video/gamecube/SDL_gamecube_events_c.h b/src/video/gamecube/SDL_gamecube_events_c.h
new file mode 100644
index 0000000000..5084d26f56
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_events_c.h
@@ -0,0 +1,4 @@
+#include "SDL_config.h"
+
+extern void GAMECUBE_InitOSKeymap(_THIS);
+extern void GAMECUBE_PumpEvents(_THIS);
diff --git a/src/video/gamecube/SDL_gamecube_mouse.c b/src/video/gamecube/SDL_gamecube_mouse.c
new file mode 100644
index 0000000000..9511d820b0
--- /dev/null
+++ b/src/video/gamecube/SDL_gamecube_mouse.c
@@ -0,0 +1,8 @@
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/ogc/SDL_ogc_video.c b/src/video/ogc/SDL_ogc_video.c
new file mode 100644
index 0000000000..69a3842c42
--- /dev/null
+++ b/src/video/ogc/SDL_ogc_video.c
@@ -0,0 +1,923 @@
+/*
+	SDL - Simple DirectMedia Layer
+	Copyright (C) 1997-2006 Sam Lantinga
+
+	This library is free software; you can redistribute it and/or
+	modify it under the terms of the GNU Lesser General Public
+	License as published by the Free Software Foundation; either
+	version 2.1 of the License, or (at your option) any later version.
+
+	This library is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+	Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public
+	License along with this library; if not, write to the Free Software
+	Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+	Tantric, 2009
+*/
+#include "SDL_config.h"
+
+// Standard includes.
+#include <math.h>
+
+// SDL internal includes.
+#include "../SDL_sysvideo.h"
+#include "../SDL_pixels_c.h"
+#include "SDL_timer.h"
+#include "SDL_thread.h"
+
+// SDL ogc specifics.
+#include <gccore.h>
+#include <ogcsys.h>
+#include <opengx.h>
+#include <malloc.h>
+#include <wiiuse/wpad.h>
+#include "SDL_ogc_video.h"
+
+#ifdef __wii__
+#include "../wii/SDL_wiievents_c.h"
+#endif
+
+#ifdef __gamecube__
+#include "../gamecube/SDL_gamecube_events_c.h"
+#endif
+
+
+#include <ogc/machine/processor.h>
+
+static const char	OGCVID_DRIVER_NAME[] = "ogc-video";
+static lwp_t videothread = LWP_THREAD_NULL;
+static SDL_mutex *videomutex = NULL;
+static SDL_cond *videocond = NULL;
+static ogcVideo *current = NULL;
+
+int vresx=0, vresy=0;
+
+/*** SDL ***/
+static SDL_Rect mode_320, mode_640;
+#ifdef __wii__
+static SDL_Rect mode_848;
+#endif
+
+static SDL_Rect* modes_descending[] =
+{
+#ifdef __wii__
+	&mode_848,
+#endif
+	&mode_640,
+	&mode_320,
+	NULL
+};
+
+
+/*** 2D Video ***/
+#define HASPECT 			320
+#define VASPECT 			240
+
+unsigned char *xfb = NULL;
+GXRModeObj* vmode = 0;
+static int quit_flip_thread = 0;
+static GXTexObj texobj_a, texobj_b;
+static GXTlutObj texpalette_a, texpalette_b;
+
+/*** GX ***/
+#define DEFAULT_FIFO_SIZE 256 * 1024
+static unsigned char gp_fifo[DEFAULT_FIFO_SIZE] __attribute__((aligned(32)));
+
+/* New texture based scaler */
+typedef struct tagcamera
+{
+	guVector pos;
+	guVector up;
+	guVector view;
+}
+camera;
+
+/*** Square Matrix
+     This structure controls the size of the image on the screen.
+	 Think of the output as a -80 x 80 by -60 x 60 graph.
+***/
+static s16 square[] ATTRIBUTE_ALIGN (32) =
+{
+  /*
+   * X,   Y,  Z
+   * Values set are for roughly 4:3 aspect
+   */
+	-HASPECT,  VASPECT, 0,	// 0
+	 HASPECT,  VASPECT, 0,	// 1
+	 HASPECT, -VASPECT, 0,	// 2
+	-HASPECT, -VASPECT, 0	// 3
+};
+
+static const f32 tex_pos[] ATTRIBUTE_ALIGN(32) = {
+	0.0, 0.0,
+	1.0, 0.0,
+	1.0, 1.0,
+	0.0, 1.0,
+};
+
+static camera cam = {
+	{0.0F, 0.0F, 0.0F},
+	{0.0F, 0.5F, 0.0F},
+	{0.0F, 0.0F, -0.5F}
+};
+
+/****************************************************************************
+ * Scaler Support Functions
+ ***************************************************************************/
+static int currentwidth;
+static int currentheight;
+static int currentbpp;
+
+static void
+draw_init(void *palette, void *tex)
+{
+	Mtx m, mv, view;
+
+	GX_ClearVtxDesc ();
+	GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
+	GX_SetVtxDesc (GX_VA_TEX0, GX_INDEX8);
+
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
+	GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
+
+	GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
+	GX_SetArray (GX_VA_TEX0, (void*)tex_pos, 2 * sizeof (f32));
+	GX_SetNumTexGens (1);
+	GX_SetNumChans (0);
+
+	GX_SetTexCoordGen (GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
+
+	GX_SetTevOp (GX_TEVSTAGE0, GX_REPLACE);
+	GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLORNULL);
+
+	memset(&view, 0, sizeof (Mtx));
+	guLookAt(view, &cam.pos, &cam.up, &cam.view);
+	guMtxIdentity(m);
+	guMtxTransApply(m, m, 0, 0, -100);
+	guMtxConcat(view, m, mv);
+	GX_LoadPosMtxImm(mv, GX_PNMTX0);
+
+	GX_InvVtxCache ();	// update vertex cache
+
+	if (currentbpp == 8) {
+		GX_InitTlutObj(&texpalette_a, palette, GX_TL_IA8, 256);
+		GX_InitTlutObj(&texpalette_b, (Uint16*)palette+256, GX_TL_IA8, 256);
+		DCStoreRange(palette, sizeof(512*sizeof(Uint16)));
+		GX_LoadTlut(&texpalette_a, GX_TLUT0);
+		GX_LoadTlut(&texpalette_b, GX_TLUT1);
+
+		GX_InitTexObjCI(&texobj_a, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT0);
+		GX_InitTexObjCI(&texobj_b, tex, currentwidth, currentheight, GX_TF_CI8, GX_CLAMP, GX_CLAMP, 0, GX_TLUT1);
+		GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+		// Setup TEV to combine Red+Green and Blue paletted images
+		GX_SetTevColor(GX_TEVREG0, (GXColor){255, 255, 0, 0});
+		GX_SetTevSwapModeTable(GX_TEV_SWAP1, GX_CH_RED, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		GX_SetTevSwapModeTable(GX_TEV_SWAP2, GX_CH_ALPHA, GX_CH_ALPHA, GX_CH_BLUE, GX_CH_ALPHA);
+		// first stage = red and green
+		GX_SetTevSwapMode(GX_TEVSTAGE0, GX_TEV_SWAP0, GX_TEV_SWAP1);
+		GX_SetTevColorIn(GX_TEVSTAGE0, GX_CC_ZERO, GX_CC_TEXC, GX_CC_C0, GX_CC_ZERO);
+		// second stage = add blue (and opaque alpha)
+		GX_SetTevOp(GX_TEVSTAGE1, GX_BLEND);
+		GX_SetTevOrder(GX_TEVSTAGE1, GX_TEXCOORD0, GX_TEXMAP1, GX_COLORNULL);
+		GX_SetTevSwapMode(GX_TEVSTAGE1, GX_TEV_SWAP0, GX_TEV_SWAP2);
+		GX_SetTevColorIn(GX_TEVSTAGE1, GX_CC_TEXC, GX_CC_ZERO, GX_CC_ZERO, GX_CC_CPREV);
+		GX_SetTevAlphaIn(GX_TEVSTAGE1, GX_CA_ZERO, GX_CA_ZERO, GX_CA_ZERO, GX_CA_KONST);
+
+		GX_SetNumTevStages(2);
+	}
+	else if (currentbpp == 16)
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
+	else
+		GX_InitTexObj(&texobj_a, tex, currentwidth, currentheight, GX_TF_RGBA8, GX_CLAMP, GX_CLAMP, GX_FALSE);
+
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);	// load texture object so its ready to use
+}
+
+static inline void
+draw_vert (u8 index)
+{
+	GX_Position1x8 (index);
+	GX_TexCoord1x8 (index);
+}
+
+static inline void
+draw_square ()
+{
+	GX_Begin(GX_QUADS, GX_VTXFMT0, 4);
+	draw_vert(0);
+	draw_vert(1);
+	draw_vert(2);
+	draw_vert(3);
+	GX_End();
+}
+
+static void * flip_thread (void *arg)
+{
+	u32 *tex = (u32*)arg;
+
+	GX_SetCurrentGXThread();
+
+	// clear EFB
+	GX_CopyDisp(xfb, GX_TRUE);
+
+	SDL_mutexP(videomutex);
+
+	while(!quit_flip_thread)
+	{
+		// update texture
+		DCStoreRange((void*)tex[0], tex[1]);
+		// clear texture objects
+		GX_InvalidateTexAll();
+		draw_square(); // render textured quad
+
+		VIDEO_WaitVSync();
+		GX_CopyDisp(xfb, GX_FALSE);
+
+		GX_DrawDone();
+
+		SDL_CondWait(videocond, videomutex);
+	}
+	SDL_mutexV(videomutex);
+
+	return NULL;
+}
+
+static void
+SetupGX()
+{
+	Mtx44 p;
+	int df = 1; // deflicker on/off
+
+	GX_SetCurrentGXThread();
+	GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
+	GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
+	GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
+
+	GX_SetDispCopySrc(0, 0, vmode->fbWidth, vmode->efbHeight);
+	GX_SetDispCopyDst(vmode->fbWidth, vmode->xfbHeight);
+	GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, (df == 1) ? GX_TRUE : GX_FALSE, vmode->vfilter);
+
+	GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
+	GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
+	GX_SetDispCopyGamma (GX_GM_1_0);
+	GX_SetCullMode (GX_CULL_NONE);
+	GX_SetBlendMode(GX_BM_NONE,GX_BL_DSTALPHA,GX_BL_INVSRCALPHA,GX_LO_CLEAR);
+
+	GX_SetZMode (GX_FALSE, GX_LEQUAL, GX_TRUE);
+	GX_SetColorUpdate (GX_TRUE);
+	GX_SetAlphaUpdate(GX_FALSE);
+
+	guOrtho(p, VASPECT, -VASPECT, -HASPECT, HASPECT, 100, 1000); // matrix, t, b, l, r, n, f
+	GX_LoadProjectionMtx (p, GX_ORTHOGRAPHIC);
+	GX_Flush();
+}
+
+static void
+StartVideoThread(void *args)
+{
+	if(videothread == LWP_THREAD_NULL)
+	{
+		quit_flip_thread = 0;
+		LWP_CreateThread(&videothread, flip_thread, args, NULL, 0, 68);
+	}
+}
+
+void OGC_VideoStart(ogcVideo *private, Uint32 flags)
+{
+	if (private==NULL) {
+		if (current==NULL)
+			return;
+		private = current;
+	}
+
+	SetupGX();
+	draw_init(private->palette, private->texturemem);
+	if (!(flags & SDL_OPENGL)) {
+		StartVideoThread(&private->texturemem);
+	}
+#ifdef __wii__
+	WPAD_SetVRes(WPAD_CHAN_0, vresx+vresx/4, vresy+vresy/4);
+#endif
+	current = private;
+}
+
+void OGC_VideoStop()
+{
+	if(videothread == LWP_THREAD_NULL)
+		return;
+
+	SDL_LockMutex(videomutex);
+	quit_flip_thread = 1;
+	SDL_CondSignal(videocond);
+	SDL_UnlockMutex(videomutex);
+
+	LWP_JoinThread(videothread, NULL);
+	videothread = LWP_THREAD_NULL;
+}
+
+static int OGC_VideoInit(_THIS, SDL_PixelFormat *vformat)
+{
+	// Set up the modes.
+#ifdef __wii__
+	mode_848.w = 848;
+	mode_848.h = 480;
+#endif
+	mode_640.w = 640;
+	mode_640.h = 480;
+	mode_320.w = 320;
+	mode_320.h = 240;
+
+	// Set the current format.
+	vformat->BitsPerPixel	= 16;
+	vformat->BytesPerPixel	= 2;
+
+	this->hidden->buffer = NULL;
+	this->hidden->texturemem = NULL;
+	this->hidden->width = 0;
+	this->hidden->height = 0;
+	this->hidden->pitch = 0;
+
+	this->gl_config.driver_loaded = 1;
+	this->gl_config.driver_path[0] = '\0';
+
+	/* We're done! */
+	return 0;
+}
+
+static SDL_Rect **OGC_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
+{
+	return modes_descending;
+}
+
+static SDL_Surface *OGC_SetVideoMode(_THIS, SDL_Surface *current,
+								   int width, int height, int bpp, Uint32 flags)
+{
+	SDL_Rect* 		mode;
+	size_t			bytes_per_pixel;
+	Uint32			r_mask = 0;
+	Uint32			b_mask = 0;
+	Uint32			g_mask = 0;
+
+	// Find a mode big enough to store the requested resolution
+	mode = modes_descending[0];
+	while (mode)
+	{
+		if (mode->w == width && mode->h == height)
+			break;
+		else
+			++mode;
+	}
+
+	// Didn't find a mode?
+	if (!mode)
+	{
+		SDL_SetError("Display mode (%dx%d) is unsupported.",
+			width, height);
+		return NULL;
+	}
+
+	if(bpp != 8 && bpp != 16 && bpp != 24 && bpp != 32)
+	{
+		SDL_SetError("Resolution (%d bpp) is unsupported (8/16/24/32 bpp only).",
+			bpp);
+		return NULL;
+	}
+
+	bytes_per_pixel = bpp / 8;
+
+	OGC_VideoStop();
+
+	free(this->hidden->buffer);
+	free(this->hidden->texturemem);
+
+	// Allocate the new buffer.
+	this->hidden->buffer = memalign(32, width * height * bytes_per_pixel);
+	if (!this->hidden->buffer )
+	{
+		this->hidden->texturemem = NULL;
+		SDL_SetError("Couldn't allocate buffer for requested mode");
+		return(NULL);
+	}
+
+	// Allocate texture memory
+	if (bytes_per_pixel > 2)
+		this->hidden->texturemem_size = width * height * 4;
+	else
+		this->hidden->texturemem_size = width * height * bytes_per_pixel;
+
+	this->hidden->texturemem = memalign(32, this->hidden->texturemem_size);
+	if (this->hidden->texturemem == NULL)
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		SDL_SetError("Couldn't allocate memory for texture");
+		return NULL;
+	}
+
+	// Allocate the new pixel format for the screen
+	if (!SDL_ReallocFormat(current, bpp, r_mask, g_mask, b_mask, 0))
+	{
+		free(this->hidden->buffer);
+		this->hidden->buffer = NULL;
+		free(this->hidden->texturemem);
+		this->hidden->texturemem = NULL;
+
+		SDL_UnlockMutex(videomutex);
+		SDL_SetError("Couldn't allocate new pixel format for requested mode");
+		return NULL;
+	}
+
+	// Clear the buffer
+	SDL_memset(this->hidden->buffer, 0, width * height * bytes_per_pixel);
+	SDL_memset(this->hidden->texturemem, 0, this->hidden->texturemem_size);
+
+	// Set up the new mode framebuffer
+	current->flags = flags & (SDL_FULLSCREEN | SDL_HWPALETTE | SDL_NOFRAME | SDL_OPENGL);
+	// Our surface is always double buffered
+	current->flags |= SDL_PREALLOC | SDL_DOUBLEBUF;
+	current->w = width;
+	current->h = height;
+	current->pitch = current->w * bytes_per_pixel;
+	current->pixels = this->hidden->buffer;
+
+	/* Set the hidden data */
+	this->hidden->width = current->w;
+	this->hidden->height = current->h;
+	this->hidden->pitch = current->w * (bytes_per_pixel > 2 ? 4 : bytes_per_pixel);
+
+	currentwidth = current->w;
+	currentheight = current->h;
+	currentbpp = bpp;
+	vresx = currentwidth;
+	vresy = currentheight;
+
+	OGC_VideoStart(this->hidden, flags);
+
+	return current;
+}
+
+/* We don't actually allow hardware surfaces other than the main one */
+static int OGC_AllocHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(-1);
+}
+
+static void OGC_FreeHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static int OGC_LockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return(0);
+}
+
+static void OGC_UnlockHWSurface(_THIS, SDL_Surface *surface)
+{
+	return;
+}
+
+static inline void Set_RGBAPixel(_THIS, int x, int y, u32 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 4) * width) + ((x >> 2) << 6) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color;
+	*(truc + offset + 1) = color >> 24;
+	*(truc + offset + 32) = color >> 16;
+	*(truc + offset + 33) = color >> 8;
+}
+
+static inline void Set_RGB565Pixel(_THIS, int x, int y, u16 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->width;
+	u32 offset;
+
+	offset = (((y >> 2) << 3) * width) + ((x >> 2) << 5) + ((((y & 3) << 2) + (x & 3)) << 1);
+
+	*(truc + offset) = color >> 8;
+	*(truc + offset + 1) = color;
+}
+
+static inline void Set_PalPixel(_THIS, int x, int y, u8 color)
+{
+	u8 *truc = this->hidden->texturemem;
+	int width = this->hidden->pitch;
+	u32 offset;
+
+	offset = ((y & ~3) * width) + ((x & ~7) << 2) + ((y & 3) << 3) + (x & 7);
+
+	truc[offset] = color;
+}
+
+static void UpdateRect_8(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 color;
+	int i, j;
+
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * (i + rect->y)) + rect->x);
+		for (j = 0; j < rect->w; j++)
+		{
+			color = src[j];
+			Set_PalPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_16(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u16 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 2 * (i + rect->y)) + (rect->x * 2));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 2);
+			color = (ptr[0] << 8) | ptr[1];
+			Set_RGB565Pixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_24(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 3 * (i + rect->y)) + (rect->x * 3));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 3);
+			color = (ptr[0] << 24) | (ptr[1] << 16) | (ptr[2] << 8) | 0xff;
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void UpdateRect_32(_THIS, SDL_Rect *rect)
+{
+	u8 *src;
+	u8 *ptr;
+	u32 color;
+	int i, j;
+	for (i = 0; i < rect->h; i++)
+	{
+		src = (this->hidden->buffer + (this->hidden->width * 4 * (i + rect->y)) + (rect->x * 4));
+		for (j = 0; j < rect->w; j++)
+		{
+			ptr = src + (j * 4);
+			color = (ptr[1] << 24) | (ptr[2] << 16) | (ptr[3] << 8) | ptr[0];
+			Set_RGBAPixel(this, rect->x + j, rect->y + i, color);
+		}
+	}
+}
+
+static void flipHWSurface_16_16(_THIS, const SDL_Surface* const surface)
+{
+	int h, w;
+	long long int *dst = (long long int *) this->hidden->texturemem;
+	long long int *src1 = (long long int *) this->hidden->buffer;
+	long long int *src2 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 1));
+	long long int *src3 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 2));
+	long long int *src4 = (long long int *) (this->hidden->buffer + (this->hidden->pitch * 3));
+	int rowpitch = (this->hidden->pitch >> 3) * 3;
+
+	SDL_mutexP(videomutex);
+	for (h = 0; h < this->hidden->height; h += 4)
+	{
+		for (w = 0; w < this->hidden->pitch; w += 8)
+		{
+			*dst++ = *src1++;
+			*dst++ = *src2++;
+			*dst++ = *src3++;
+			*dst++ = *src4++;
+		}
+
+		src1 = src4;
+		src2 += rowpitch;
+		src3 += rowpitch;
+		src4 += rowpitch;
+	}
+	SDL_CondSignal(videocond);
+	SDL_mutexV(videomutex);
+}
+
+static void OGC_UpdateRect(_THIS, SDL_Rect *rect)
+{
+	const SDL_Surface* const screen = this->screen;
+
+	switch(screen->format->BytesPerPixel) {
+	case 1:
+		UpdateRect_8(this, rect);
+		break;
+	case 2:
+		UpdateRect_16(this, rect);
+		break;
+	case 3:
+		UpdateRect_24(this, rect);
+		break;
+	case 4:
+		UpdateRect_32(this, rect);
+		break;
+	default:
+		fprintf(stderr, "Invalid BPP %d\n", screen->format->BytesPerPixel);
+		break;
+	}
+}
+
+static void OGC_UpdateRects(_THIS, int numrects, SDL_Rect *rects)
+{
+	int i;
+
+	// note that this function doesn't lock - we don't care if this isn't
+	// rendered now, that's what Flip is for
+
+	for (i = 0; i < numrects; i++)
+	{
+		OGC_UpdateRect(this, rects+i);
+	}
+
+	SDL_CondSignal(videocond);
+}
+
+static void flipHWSurface_24_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	OGC_UpdateRects(this, 1, &screen_rect);
+}
+
+static void flipHWSurface_32_16(_THIS, SDL_Surface *surface)
+{
+	SDL_Rect screen_rect = {0, 0, this->hidden->width, this->hidden->height};
+	OGC_UpdateRects(this, 1, &screen_rect);
+}
+
+static int OGC_FlipHWSurface(_THIS, SDL_Surface *surface)
+{
+	switch(surface->format->BytesPerPixel)
+	{
+		case 1:
+		case 2:
+			// 8 and 16 bit use the same tile format
+			flipHWSurface_16_16(this, surface);
+			break;
+		case 3:
+			flipHWSurface_24_16(this, surface);
+			break;
+		case 4:
+			flipHWSurface_32_16(this, surface);
+			break;
+		default:
+			return -1;
+	}
+	return 0;
+}
+
+static int OGC_SetColors(_THIS, int first_color, int color_count, SDL_Color *colors)
+{
+	const int last_color = first_color + color_count;
+	Uint16* const palette = this->hidden->palette;
+	int     component;
+
+	SDL_LockMutex(videomutex);
+
+	/* Build the RGB24 palette. */
+	for (component = first_color; component != last_color; ++component, ++colors)
+	{
+		palette[component] = (colors->g << 8) | colors->r;
+		palette[component+256] = colors->b;
+	}
+
+	DCStoreRangeNoSync(palette+first_color, color_count*sizeof(Uint16));
+	DCStoreRange(palette+first_color+256, color_count*sizeof(Uint16));
+	GX_LoadTlut(&texpalette_a, GX_TLUT0);
+	GX_LoadTlut(&texpalette_b, GX_TLUT1);
+	GX_LoadTexObj(&texobj_a, GX_TEXMAP0);
+	GX_LoadTexObj(&texobj_b, GX_TEXMAP1);
+
+	SDL_UnlockMutex(videomutex);
+
+	return(1);
+}
+
+static void OGC_VideoQuit(_THIS)
+{
+	OGC_VideoStop();
+	GX_AbortFrame();
+	GX_Flush();
+
+	current = NULL;
+
+	VIDEO_SetBlack(TRUE);
+	VIDEO_Flush();
+
+	free(this->hidden->buffer);
+	this->hidden->buffer = NULL;
+	free(this->hidden->texturemem);
+	this->hidden->texturemem = NULL;
+}
+
+static void OGC_DeleteDevice(SDL_VideoDevice *device)
+{
+	free(device->hidden);
+	SDL_free(device);
+
+	SDL_DestroyCond(videocond);
+	videocond = 0;
+	SDL_DestroyMutex(videomutex);
+	videomutex=0;
+}
+
+/* Weak symbols for the opengx functions used by SDL, so that the client does
+ * not need to link to opengx, unless it actually uses OpenGL. */
+void __attribute__((weak)) ogx_initialize(void)
+{
+}
+
+void __attribute__((weak)) *ogx_get_proc_address(const char *)
+{
+    return NULL;
+}
+
+int SDL_OGC_GL_LoadLibrary(_THIS, const char *path)
+{
+	return 0;
+}
+
+void *SDL_OGC_GL_GetProcAddress(_THIS, const char *proc)
+{
+	void *ptr = ogx_get_proc_address(proc);
+	if (!ptr) {
+		fprintf(stderr, "GetProcAddress %s\n", proc);
+	}
+	return ptr;
+}
+
+int SDL_OGC_GL_MakeCurrent(_THIS)
+{
+	ogx_initialize();
+	return 0;
+}
+
+void SDL_OGC_GL_SwapBuffers(_THIS)
+{
+	VIDEO_WaitVSync();
+	GX_CopyDisp(xfb, GX_FALSE);
+
+	GX_DrawDone();
+}
+
+static SDL_VideoDevice *OGC_CreateDevice(int devindex)
+{
+	SDL_VideoDevice *device;
+
+	/* Initialize all variables that we clean on shutdown */
+	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
+	if ( device ) {
+		SDL_memset(device, 0, (sizeof *device));
+		device->hidden = (struct SDL_PrivateVideoData *)
+			memalign(32, sizeof(struct SDL_PrivateVideoData));
+	}
+	if ( (device == NULL) || (device->hidden == NULL) ) {
+		SDL_OutOfMemory();
+		if ( device ) {
+			SDL_free(device);
+		}
+		return(0);
+	}
+	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
+
+	videomutex = SDL_CreateMutex();
+	videocond = SDL_CreateCond();
+
+	/* Set the function pointers */
+	device->VideoInit = OGC_VideoInit;
+	device->ListModes = OGC_ListModes;
+	device->SetVideoMode = OGC_SetVideoMode;
+	device->SetColors = OGC_SetColors;
+	device->UpdateRects = OGC_UpdateRects;
+	device->VideoQuit = OGC_VideoQuit;
+	device->AllocHWSurface = OGC_AllocHWSurface;
+	device->LockHWSurface = OGC_LockHWSurface;
+	device->UnlockHWSurface = OGC_UnlockHWSurface;
+	device->FlipHWSurface = OGC_FlipHWSurface;
+	device->FreeHWSurface = OGC_FreeHWSurface;
+#ifdef __wii__
+	device->InitOSKeymap = WII_InitOSKeymap;
+	device->PumpEvents = WII_PumpEvents;
+#endif
+#ifdef __gamecube__
+	device->InitOSKeymap = GAMECUBE_InitOSKeymap;
+	device->PumpEvents = GAMECUBE_PumpEvents;
+#endif
+	device->input_grab = SDL_GRAB_ON;
+
+	device->GL_LoadLibrary = SDL_OGC_GL_LoadLibrary;
+	device->GL_GetProcAddress = SDL_OGC_GL_GetProcAddress;
+	device->GL_MakeCurrent = SDL_OGC_GL_MakeCurrent;
+	device->GL_SwapBuffers = SDL_OGC_GL_SwapBuffers;
+
+	device->free = OGC_DeleteDevice;
+
+	OGC_InitVideoSystem();
+	return device;
+}
+
+static int OGC_Available(void)
+{
+	return(1);
+}
+
+VideoBootStrap OGC_bootstrap = {
+	OGCVID_DRIVER_NAME, "ogc video driver",
+	OGC_Available, OGC_CreateDevice
+};
+
+void
+OGC_InitVideoSystem()
+{
+	/* Initialise the video system */
+	VIDEO_Init();
+	vmode = VIDEO_GetPreferredMode(NULL);
+
+	/* Set up the video system with the chosen mode */
+	if (vmode == &TVPal528IntDf)
+		vmode = &TVPal576IntDfScale;
+
+	VIDEO_Configure(vmode);
+
+	// Allocate the video buffer
+	if (xfb) free(MEM_K1_TO_K0(xfb));
+	xfb = (unsigned char*) MEM_K0_TO_K1(SYS_AllocateFramebuffer(vmode));
+
+	VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
+	VIDEO_SetNextFramebuffer(xfb);
+
+	// Show the screen.
+	VIDEO_SetBlack(FALSE);
+	VIDEO_Flush();
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
+
+	//CON_Init(xfb,20,20,vmode->fbWidth,vmode->xfbHeight,vmode->fbWidth*VI_DISPLAY_PIX_SZ);
+
+	/*** Clear out FIFO area ***/
+	memset(&gp_fifo, 0, DEFAULT_FIFO_SIZE);
+
+	/*** Initialise GX ***/
+	GX_Init(&gp_fifo, DEFAULT_FIFO_SIZE);
+
+	GXColor background = { 0, 0, 0, 0xff };
+	GX_SetCopyClear (background, GX_MAX_Z24);
+
+	SetupGX();
+}
+
+void OGC_SetWidescreen(int wide)
+{
+	int width;
+	if(wide) {
+		width = 678;
+	}
+	else
+		width = 640;
+
+	vmode->viWidth = width;
+	vmode->viXOrigin = (VI_MAX_WIDTH_NTSC - width) / 2;
+
+	VIDEO_Configure (vmode);
+
+	if (xfb)
+		VIDEO_ClearFrameBuffer(vmode, xfb, COLOR_BLACK);
+
+	VIDEO_Flush();
+
+	VIDEO_WaitVSync(); VIDEO_WaitVSync();
+}
+
+void OGC_ChangeSquare(int xscale, int yscale, int xshift, int yshift)
+{
+	square[6] = square[3]  =  xscale + xshift;
+	square[0] = square[9]  = -xscale + xshift;
+	square[4] = square[1]  =  yscale - yshift;
+	square[7] = square[10] = -yscale - yshift;
+	DCFlushRange (square, 32); // update memory BEFORE the GPU accesses it!
+	GX_InvVtxCache();
+}
diff --git a/src/video/ogc/SDL_ogc_video.h b/src/video/ogc/SDL_ogc_video.h
new file mode 100644
index 0000000000..a86ad89b45
--- /dev/null
+++ b/src/video/ogc/SDL_ogc_video.h
@@ -0,0 +1,37 @@
+#include "SDL_config.h"
+
+#ifndef _SDL_ogc_video_h
+#define _SDL_ogc_video_h
+
+/* SDL internal includes */
+#include "../SDL_sysvideo.h"
+
+/* OGC includes */
+#include <ogc/gx_struct.h>
+
+/* Hidden "this" pointer for the video functions */
+#define _THIS   SDL_VideoDevice *this
+
+/* Private display data */
+typedef struct SDL_PrivateVideoData
+{
+    // 2x256x16bit palettes = 1x256x24(32)bit palette
+    // first 256 entries are for Red/Green
+    // last 256 entries are for Green
+    Uint16 palette[2*256];
+
+    Uint8* buffer;
+
+    // these two fields MUST be in this order
+    Uint8* texturemem;
+    size_t texturemem_size;
+
+    int    width;
+    int    height;
+    int    pitch;
+} ogcVideo;
+
+void OGC_InitVideoSystem();
+void OGC_ChangeSquare(int xscale, int yscale, int xshift, int yshift);
+
+#endif /* _SDL_wiivideo_h */
diff --git a/src/video/wii/SDL_wiievents.c b/src/video/wii/SDL_wiievents.c
new file mode 100644
index 0000000000..2688bda3f2
--- /dev/null
+++ b/src/video/wii/SDL_wiievents.c
@@ -0,0 +1,264 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+    Yohanes Nugroho (yohanes@gmail.com)
+	Tantric
+*/
+#include "SDL_config.h"
+
+#include "../../events/SDL_sysevents.h"
+#include "../../events/SDL_events_c.h"
+#include <wiiuse/wpad.h>
+#include <malloc.h>
+#include <unistd.h>
+#include <ogc/usbmouse.h>
+#include <wiikeyboard/keyboard.h>
+#include <ogc/pad.h>
+
+#include "SDL_wiievents_c.h"
+
+static SDLKey keymap[232];
+
+static int posted;
+
+extern bool TerminateRequested;
+extern void Terminate();
+extern int vresx, vresy;
+
+void PumpEvents()
+{
+	s32 stat;
+#ifdef HW_RVL
+	keyboard_event ke;
+	mouse_event me;
+
+	if (TerminateRequested) Terminate();
+#endif
+
+	// this will only work if Joystick 0 has been opened and has been polled
+	WPADData *wd = WPAD_Data(WPAD_CHAN_0);
+
+	static Uint8 lastButtonStateA = SDL_RELEASED;
+	static Uint8 lastButtonStateB = SDL_RELEASED;
+
+	Uint8 stateA = (wd->btns_h & WPAD_BUTTON_A) ? SDL_PRESSED : SDL_RELEASED;
+	Uint8 stateB = (wd->btns_h & WPAD_BUTTON_B) ? SDL_PRESSED : SDL_RELEASED;
+
+	if (stateA != lastButtonStateA)
+	{
+		lastButtonStateA = stateA;
+		posted += SDL_PrivateMouseButton(stateA, SDL_BUTTON_LEFT, 0, 0);
+	}
+
+	if (stateB != lastButtonStateB)
+	{
+		lastButtonStateB = stateB;
+		posted += SDL_PrivateMouseButton(stateB, SDL_BUTTON_RIGHT, 0, 0);
+	}
+
+
+	if (wd && wd->exp.type != WPAD_EXP_CLASSIC && wd->ir.valid) {
+
+		// use SDL_BUTTON_X2 to signal that this is the wiimote acting as a mouse
+		Uint8 Buttons = SDL_GetMouseState(NULL, NULL)|SDL_BUTTON_X2MASK;
+
+		if (wd->ir.x < vresx/8)
+			wd->ir.x = vresx/8;
+		else if (wd->ir.x > (vresx + vresx/8))
+			wd->ir.x = vresx + vresx/8;
+		if (wd->ir.y < vresy/8)
+			wd->ir.y = vresy/8;
+		else if (wd->ir.y > (vresy + vresy/8))
+			wd->ir.y = vresy + vresy/8;
+		posted += SDL_PrivateMouseMotion(Buttons, 0, wd->ir.x - vresx/8, wd->ir.y - vresy/8);
+		// most apps will ignore this (hopefully)
+		posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_X2, 0, 0);
+		wd->ir.valid = 0;
+	}
+
+	stat = KEYBOARD_GetEvent(&ke);
+	if (stat && (ke.type == KEYBOARD_RELEASED || ke.type == KEYBOARD_PRESSED))
+	{
+		SDL_keysym keysym;
+		memset(&keysym, 0, sizeof(keysym));
+		Uint8 keystate = (ke.type == KEYBOARD_PRESSED) ? SDL_PRESSED : SDL_RELEASED;
+		keysym.sym = keymap[ke.keycode];
+		keysym.unicode = ke.symbol;
+		keysym.mod = 0;
+		posted += SDL_PrivateKeyboard(keystate, &keysym);
+	}
+
+	stat = MOUSE_GetEvent(&me);
+	if (stat)
+	{
+		u8 button = me.button;
+		Uint8 mouse_state = SDL_GetMouseState(NULL, NULL);
+
+		posted += SDL_PrivateMouseMotion(0, 1, me.rx*2, me.ry*2);
+
+		if (button & 0x1) {
+			if (!(mouse_state & SDL_BUTTON_LMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_LEFT, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_LMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_LEFT, 0, 0);
+
+		if (button & 0x2) {
+			if (!(mouse_state & SDL_BUTTON_RMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_RIGHT, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_RMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_RIGHT, 0, 0);
+
+		if (button & 0x4) {
+			if (!(mouse_state & SDL_BUTTON_MMASK))
+				posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_MIDDLE, 0, 0);
+		}
+		else if (mouse_state & SDL_BUTTON_MMASK)
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_MIDDLE, 0, 0);
+
+		// mouse wheel actions are single events (rz==1(up) or rz==-1(down))
+		// send SDL_PRESSED immediately followed by SDL_RELEASED
+		if (me.rz > 0) {
+			posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELUP, 0, 0);
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELUP, 0, 0);
+		}
+		else if (me.rz < 0) {
+			posted += SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELDOWN, 0, 0);
+			posted += SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELDOWN, 0, 0);
+		}
+	}
+}
+
+void WII_PumpEvents(_THIS)
+{
+	do
+	{
+		posted = 0;
+		PumpEvents();
+		usleep(100);
+	} while (posted);
+}
+
+void WII_InitOSKeymap(_THIS)
+{
+	int i;
+
+	for (i = 0; i < 232; ++i)
+		keymap[i] = SDLK_UNKNOWN;
+
+	// a-z
+	for (i = 0; i < 27; i++)
+		keymap[4 + i] = SDLK_a + i;
+
+	// 1-9
+	for (i = 0; i < 9; i++)
+		keymap[30 + i] = SDLK_1 + i;
+
+	keymap[39] = SDLK_0;
+	keymap[40] = SDLK_RETURN;
+	keymap[41] = SDLK_ESCAPE;
+	keymap[42] = SDLK_BACKSPACE;
+	keymap[43] = SDLK_TAB;
+	keymap[44] = SDLK_SPACE;
+	keymap[45] = SDLK_MINUS;
+	keymap[46] = SDLK_EQUALS;
+	keymap[47] = SDLK_LEFTBRACKET;
+	keymap[48] = SDLK_RIGHTBRACKET;
+	keymap[49] = SDLK_BACKSLASH;
+	keymap[50] = SDLK_UNKNOWN; // unused
+	keymap[51] = SDLK_SEMICOLON;
+	keymap[52] = SDLK_QUOTE;
+	keymap[53] = SDLK_BACKQUOTE;
+	keymap[54] = SDLK_COMMA;
+	keymap[55] = SDLK_PERIOD;
+	keymap[56] = SDLK_SLASH;
+	keymap[57] = SDLK_CAPSLOCK;
+
+	// F1 to F12
+	for (i = 0; i < 12; i++)
+		keymap[58 + i] = SDLK_F1 + i;
+
+	keymap[70] = SDLK_PRINT;
+	keymap[71] = SDLK_SCROLLOCK;
+	keymap[72] = SDLK_PAUSE;
+	keymap[73] = SDLK_INSERT;
+	keymap[74] = SDLK_HOME;
+	keymap[75] = SDLK_PAGEUP;
+	keymap[76] = SDLK_DELETE;
+	keymap[77] = SDLK_END;
+	keymap[78] = SDLK_PAGEDOWN;
+
+	keymap[79] = SDLK_RIGHT;
+	keymap[80] = SDLK_LEFT;
+	keymap[81] = SDLK_DOWN;
+	keymap[82] = SDLK_UP;
+	keymap[83] = SDLK_NUMLOCK;
+
+	keymap[84] = SDLK_KP_DIVIDE;
+	keymap[85] = SDLK_KP_MULTIPLY;
+	keymap[86] = SDLK_KP_MINUS;
+	keymap[87] = SDLK_KP_PLUS;
+
+	keymap[88] = SDLK_KP_ENTER;
+
+	// keypad 1-9
+	for (i = 0; i < 9; i++)
+		keymap[89 + i] = SDLK_KP1 + i;
+
+	keymap[98] = SDLK_KP0;
+	keymap[99] = SDLK_KP_PERIOD;
+	keymap[100] = SDLK_UNKNOWN; // unused
+	keymap[101] = SDLK_UNKNOWN; // Applic
+	keymap[102] = SDLK_POWER;
+	keymap[103] = SDLK_KP_EQUALS;
+	keymap[104] = SDLK_F13;
+	keymap[105] = SDLK_F14;
+	keymap[106] = SDLK_F15;
+	keymap[107] = SDLK_UNKNOWN; // F16
+	keymap[108] = SDLK_UNKNOWN; // F17
+	keymap[109] = SDLK_UNKNOWN; // F18
+	keymap[110] = SDLK_UNKNOWN; // F19
+	keymap[111] = SDLK_UNKNOWN; // F20
+	keymap[112] = SDLK_UNKNOWN; // F21
+	keymap[113] = SDLK_UNKNOWN; // F22
+	keymap[114] = SDLK_UNKNOWN; // F23
+	keymap[115] = SDLK_UNKNOWN; // F24
+	keymap[116] = SDLK_UNKNOWN; // Execute
+	keymap[117] = SDLK_HELP;
+	keymap[118] = SDLK_MENU;
+	keymap[119] = SDLK_UNKNOWN; // Select
+	keymap[120] = SDLK_UNKNOWN; // Stop
+	keymap[121] = SDLK_UNKNOWN; // Again
+	keymap[122] = SDLK_UNDO;
+
+	keymap[134] = SDLK_KP_EQUALS;
+	// 135-143 - International
+	// 144-152 - Language
+	keymap[154] = SDLK_SYSREQ;
+
+	keymap[224] = SDLK_LCTRL;
+	keymap[225] = SDLK_LSHIFT;
+	keymap[226] = SDLK_LALT;
+	keymap[227] = SDLK_LMETA;
+	keymap[228] = SDLK_RCTRL;
+	keymap[229] = SDLK_RSHIFT;
+	keymap[230] = SDLK_RALT;
+	keymap[231] = SDLK_RMETA;
+}
diff --git a/src/video/wii/SDL_wiievents_c.h b/src/video/wii/SDL_wiievents_c.h
new file mode 100644
index 0000000000..030cb06c09
--- /dev/null
+++ b/src/video/wii/SDL_wiievents_c.h
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "../ogc/SDL_ogc_video.h"
+
+/* Variables and functions exported by SDL_sysevents.c to other parts 
+   of the native video subsystem (SDL_sysvideo.c)
+*/
+extern void WII_InitOSKeymap(_THIS);
+extern void WII_PumpEvents(_THIS);
+
+/* end of SDL_wiievents_c.h ... */
+
diff --git a/src/video/wii/SDL_wiimouse.c b/src/video/wii/SDL_wiimouse.c
new file mode 100644
index 0000000000..cd41fbf7b6
--- /dev/null
+++ b/src/video/wii/SDL_wiimouse.c
@@ -0,0 +1,33 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "SDL_mouse.h"
+#include "../../events/SDL_events_c.h"
+
+#include "SDL_wiimouse_c.h"
+
+
+/* The implementation dependent data for the window manager cursor */
+struct WMcursor {
+	int unused;
+};
diff --git a/src/video/wii/SDL_wiimouse_c.h b/src/video/wii/SDL_wiimouse_c.h
new file mode 100644
index 0000000000..b4c260e6f1
--- /dev/null
+++ b/src/video/wii/SDL_wiimouse_c.h
@@ -0,0 +1,26 @@
+/*
+    SDL - Simple DirectMedia Layer
+    Copyright (C) 1997-2006 Sam Lantinga
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    Sam Lantinga
+    slouken@libsdl.org
+*/
+#include "SDL_config.h"
+
+#include "../ogc/SDL_ogc_video.h"
+
+/* Functions to be exported */
diff --git a/src/video/wincommon/SDL_sysevents.c b/src/video/wincommon/SDL_sysevents.c
index 090f6f161c..76c67a1ccd 100644
--- a/src/video/wincommon/SDL_sysevents.c
+++ b/src/video/wincommon/SDL_sysevents.c
@@ -310,8 +310,8 @@ LRESULT CALLBACK WinMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
 					if ( WINDIB_FULLSCREEN() ) {
 						appstate |= SDL_APPMOUSEFOCUS;
 						SDL_RestoreDesktopMode();
-						/* A fullscreen app gets hidden but will not get a minimize event */
-						appstate |= (SDL_APPACTIVE | SDL_APPMOUSEFOCUS);
+						/* A fullscreen app gets hidden but will not get a minimize event */
+						appstate |= (SDL_APPACTIVE | SDL_APPMOUSEFOCUS);
 #if defined(_WIN32_WCE)
 						LoadAygshell();
 						if( SHFullScreen ) 
